<!DOCTYPE html>
<html lang="en">
    <meta charset="UTF-8">

<title>cMulti Visualizer v0.0.4</title>

<style>
h1 {
  font-family: "Courier New", Courier, monospace;
}
body {  background-color: white;
  color: black;
    font-family: "Courier New", Courier, monospace;
  }
  canvas {  background-color: white;
  color: white;}
  th, td {
  padding: 7px;
    border: 1px solid black;
  border-collapse: collapse;
}
</style>
<body>
<h1>cMultiVisualizer</h1>
<h2>Visualizing functions in split-complex and finite multipolar complex planes</h2>
v0.0.4
<!--
v0.0.1 - First version
v0.0.2 - Added glitch mode, safe/accurate mode toggle.
v0.0.3 - Generalized hexapolarity to any quantity of signs.
v0.0.4 - Updated:
			- output filename to include sign quantity parameter and QIII signs
			- range of accepted inputs for axes signs
			- user-specifiable quadrants with default "lock mode" that weds I & II and III & IV by imaginary sign and weds I&IV and II&III by reallike sign.  
-->
<table>
  <tr>
    <th>Number System</th>
    <th><a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot</a><br>z<sub>(i+1)</sub>=z<sub>i</sub><sup>n</sup>+c</th> 
    <th>MandelbrotS<br>z<sub>(i+1)</sub>=(z<sub>i</sub>s)<sup>n</sup>+c</th>
        <th><a href="https://en.wikipedia.org/wiki/Tricorn_(mathematics)">Tricorn</a><br>z<sub>(i+1)</sub>=z<sub>i</sub>*<sup>n</sup>+c</th>
    <th>TricornSC<br>z<sub>(i+1)</sub>=(z<sub>i</sub>s)*<sup>n</sup>+c</th> 
    <th>TricornCS<br>z<sub>(i+1)</sub>=((z<sub>i</sub>*)s)<sup>n</sup>+c</th>
  </tr>
  <tr>
    <td><a href="https://en.wikipedia.org/wiki/Complex_number">Complex</a> & <a href="https://www.benblohowiak.com/complexhexapolardraft.html">Complex Multipolar</a></td>
    <td>1</td> 
    <td>2</td>
        <td>3</td>
    <td>6</td> 
    <td>7</td>
  </tr>
  <tr>
    <td><a href="https://en.wikipedia.org/wiki/Split-complex_number">Split-Complex</a></td>
    <td>10</td> 
    <td>n/a</td>
        <td>11</td>
    <td>n/a</td> 
    <td>n/a</td>
  </tr>
</table>



     <label for="whichFractalInput"><b>Function to visualize: </b></label>
    <input type="number"
           id="whichFractalInput" min="1" max="11" step="1" value="1">
           
           <label for='signQuantInput'><b>Sign quantity (if multipolar): </b></label>
           <input type='number' id='signQuantInput' min='2' max='9999' step='4' value='2' oninput='validity.valid||(value=&quot;&quot;);'>
           
           
           
    <button onclick="showParameters()">Click here to select or change function and <br>access its rendering parameters in safe/accurate mode</button>
    <button onclick="showParameters2()">Click here to select or change function and <br>access its rendering parameters in g7iTCh M0DE</button>
    
<table>    
<td><p id="parameters10"></p></td>
<td><p id="parameters02"></p></td>
<td><p id="parameters03"></p></td>
</table>

<p id="parameters04a"></p>
<table>    
<td><p id="parameters04"></p></td>
<td><p id="parameters05"></p></td>
</table>
 
<table>    
<td><p id="parameters06"></p></td>
<td><p id="parameters07"></p></td>

</table>
 
<table>    
<td><p id="parameters04b"></p></td>
<td><p id="parameters05b"></p></td>
</table>
 
<table>    
<td><p id="parameters06b"></p></td>
<td><p id="parameters07b"></p></td>

</table>

           
           
           
<br>
           <label for="zoomInput"><b>Zoom [0-42]: </b></label>
    <input type="number"
           id="zoomInput" min="0" max="42" step=".00975625" value="0" >
           
        <br><label for="colorModeInput"><b>Color mode (modulo enabled for modes 2-4): </b></label>
    <input type="number"
           id="colorModeInput" min="0" max="5" step="1" value="3" oninput="validity.valid||(value='');">
 
        <label for="colorModInput"><b>Modulo offset [0-100]: </b></label>
    <input type="number"
           id="colorModInput" min="0" max="100" step="1" value="0" oninput="validity.valid||(value='');">
<p id="parameters0S"></p>
 
    <br><p id="renderprogress"></p><br> 
 
    <button onclick="metaRender()">Click here to render with above variables; output will automatically toggle <br>between four-quadrant and one-orthant modes...if changing <br>functions, remember to click that button above</button><br>
<p id="download"></p> 
 
<p id= "downloadEZ"></p>
 
 
    <p id="result"
       style="color:red; 
              font-weight:bold;">
    </p>
    <script>
    
function showParameters(){    
            fractGlitch="Fract";      
            whichFractal = Number(document.getElementById("whichFractalInput").value);
            signQuant = Number(document.getElementById("signQuantInput").value);
	if (whichFractal<10){
//parameters10="		<label for='signQuantInput'><b>Sign quantity: </b></label><input type='number' id='signQuantInput' min='6' max='9999' step='4' value='6' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters02="      <label for='exponentInput'><b>Exponent (n): </b></label><input type='number' id='exponentInput' min='2' max='9999' step='1' value='2' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters03="<label for='iterationsInput'><b>Iterations to attempt: </b></label><input type='number' id='iterationsInput' min='1' max='1000' step='1' value='19' oninput='validity.valid||(value=&quot;&quot;);'> ";
parameters04a="FYI: Quadrants of the complex plane in the six-signed complex hexapolar plane: (s^0,s^2); (s^6,s^2); (s^6,s^8); (s^0,s^8)<br>";
parameters04="<label for='realSignInput'><b>Quadrant I Horizontal Axis Sign: s^</b></label><input type='number' id='realSignInput' min='0' max='"+((2*signQuant)-2)+"' step='2' value='0' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters05="<label for='xInput'><b>...extension rightward to real/reallike magnitude: </b></label><input type='number' id='xInput' min='0' max='1000' step='.000001' value='2' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters06="<label for='imSignInput'><b>Quadrant I Vertical Axis Sign: s^</b></label><input type='number' id='imSignInput' min='0' max='"+((2*signQuant)-2)+"' step='2' value='"+((signQuant/2)-1)+"' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters07="<label for='yInput'><b>...extension up from <em>s</em>-axis magnitude: </b></label><input type='number' id='yInput' min='0' max='1000' step='.000001' value='0' oninput='validity.valid||(value=&quot;&quot;);'>";

parameters04b="<label for='realSignInputIII'><b>Quadrant III Horizontal Axis Sign: s^</b></label><input type='number' id='realSignInputIII' min='0' max='"+((2*signQuant)-2)+"' step='2' value='"+signQuant+"' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters05b="<label for='xInputIII'><b>...extension leftward to real/reallike magnitude: </b></label><input type='number' id='xInputIII' min='0' max='1000' step='.000001' value='2' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters06b="<label for='imSignInputIII'><b>Quadrant III Vertical Axis Sign: s^</b></label><input type='number' id='imSignInputIII' min='0' max='"+((2*signQuant)-2)+"' step='2' value='"+((signQuant/2)-1+signQuant)+"' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters07b="<label for='yInputIII'><b>...extension down from <em>s</em>-axis magnitude: </b></label><input type='number' id='yInputIII' min='0' max='1000' step='.000001' value='0' oninput='validity.valid||(value=&quot;&quot;);'>";


parameters0S="<label for='outputSizeInput'><b>Orthant size (bigger inputs -> longer render time): </b></label> <input type='number' id='outputSizeInput' min='20' max='2000' step='1' value='200' oninput='validity.valid||(value=&quot;&quot;);'>";

//		document.getElementById("parameters10").innerHTML = parameters10; 
		document.getElementById("parameters02").innerHTML = parameters02;
		document.getElementById("parameters03").innerHTML = parameters03;
		document.getElementById("parameters04").innerHTML = parameters04;
		document.getElementById("parameters04a").innerHTML = parameters04a;
		document.getElementById("parameters05").innerHTML = parameters05;
		document.getElementById("parameters06").innerHTML = parameters06;
		document.getElementById("parameters07").innerHTML = parameters07;
		
		document.getElementById("parameters04b").innerHTML = parameters04b;
//		document.getElementById("parameters05b").innerHTML = parameters05b;
		document.getElementById("parameters06b").innerHTML = parameters06b;
//		document.getElementById("parameters07b").innerHTML = parameters07b;			
//		document.getElementById("parameters08").innerHTML = parameters08;
//		document.getElementById("parameters09").innerHTML = parameters09;
		document.getElementById("parameters0S").innerHTML = parameters0S;
 
} else {
parameters02="      <label for='exponentInput'><b>Exponent (n): </b></label><input type='number' id='exponentInput' min='2' max='9999' step='1' value='2' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters03="<label for='iterationsInput'><b>Iterations to attempt: </b></label><input type='number' id='iterationsInput' min='1' max='300' step='1' value='19' oninput='validity.valid||(value=&quot;&quot;);'> ";
parameters04="Quadrant I or Orthant rendered";
parameters04a="";
parameters05="<label for='xInput'><b>Extending rightward to real magnitude: </b></label><input type='number' id='xInput' min='-1000' max='1000' step='.000001' value='2';'>";
parameters06="Quadrant I or Orthant rendered";
parameters07="<label for='yInput'><b>Extending up from <em>j</em>-axis magnitude: </b></label><input type='number' id='yInput' min='-1000' max='1000' step='.000001' value='0' ;'>";
parameters0S="<label for='outputSizeInput'><b>Orthant size (bigger inputs -> longer render time): </b></label> <input type='number' id='outputSizeInput' min='20' max='2000' step='1' value='200' oninput='validity.valid||(value='');'>";

		document.getElementById("parameters02").innerHTML = parameters02;
		document.getElementById("parameters03").innerHTML = parameters03;
		document.getElementById("parameters04").innerHTML = parameters04;
		document.getElementById("parameters04a").innerHTML = parameters04a;
		document.getElementById("parameters05").innerHTML = parameters05;
		document.getElementById("parameters06").innerHTML = parameters06;
		document.getElementById("parameters07").innerHTML = parameters07;
				
		document.getElementById("parameters0S").innerHTML = parameters0S;

}
} 

function showParameters2(){    
			fractGlitch="Glitch";

            whichFractal = Number(document.getElementById("whichFractalInput").value);
	if (whichFractal<10){
//parameters10="      <label for='signQuantInput'><b>Sign quantity: </b></label><input type='number' id='signQuantInput' min='1' max='9999' step='.25' value='2' oninput='validity.valid||(value=&quot;&quot;);'>";	
parameters02="      <label for='exponentInput'><b>Exponent (n): </b></label><input type='number' id='exponentInput' min='2' max='9999' step='1' value='2' >";
parameters03="<label for='iterationsInput'><b>Iterations to attempt: </b></label><input type='number' id='iterationsInput' min='1' max='1000' step='1' value='19' oninput='validity.valid||(value=&quot;&quot;);'> ";
parameters04a="FYI: YOU ARE IN GLITCH MODE";
parameters04="<label for='realSignInput'><b>Quadrant I Horizontal Axis Sign: s^</b></label><input type='number' id='realSignInput' min='0' max='"+((2*signQuant)-2)+"' step='.5' value='0'>";
parameters05="<label for='xInput'><b>...extension rightward to real/reallike magnitude: </b></label><input type='number' id='xInput' min='0' max='1000' step='.000001' value='2' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters06="<label for='imSignInput'><b>Quadrant I Vertical Axis Sign: s^</b></label><input type='number' id='imSignInput' min='0' max='"+((2*signQuant)-2)+"' step='.5' value='2'>";
parameters07="<label for='yInput'><b>...extension up from <em>s</em>-axis magnitude: </b></label><input type='number' id='yInput' min='0' max='1000' step='.000001' value='0' oninput='validity.valid||(value=&quot;&quot;);';'>";
parameters0S="<label for='outputSizeInput'><b>Orthant size (bigger inputs -> longer render time): </b></label> <input type='number' id='outputSizeInput' min='20' max='2000' step='.5' value='200.5' >"

parameters04b="<label for='realSignInputIII'><b>Quadrant III Horizontal Axis Sign: s^</b></label><input type='number' id='realSignInputIII' min='0' max='"+((2*signQuant)-2)+"' step='2' value='"+signQuant+"' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters05b="<label for='xInputIII'><b>...extension leftward to real/reallike magnitude: </b></label><input type='number' id='xInputIII' min='0' max='1000' step='.000001' value='2' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters06b="<label for='imSignInputIII'><b>Quadrant III Vertical Axis Sign: s^</b></label><input type='number' id='imSignInputIII' min='0' max='"+((2*signQuant)-2)+"' step='2' value='8' oninput='validity.valid||(value=&quot;&quot;);'>";
parameters07b="<label for='yInputIII'><b>...extension down from <em>s</em>-axis magnitude: </b></label><input type='number' id='yInputIII' min='0' max='1000' step='.000001' value='0' oninput='validity.valid||(value=&quot;&quot;);'>";



 
// 		document.getElementById("parameters10").innerHTML = parameters10;
		document.getElementById("parameters02").innerHTML = parameters02;
		document.getElementById("parameters03").innerHTML = parameters03;
		document.getElementById("parameters04").innerHTML = parameters04;
		document.getElementById("parameters04a").innerHTML = parameters04a;
		document.getElementById("parameters05").innerHTML = parameters05;
		document.getElementById("parameters06").innerHTML = parameters06;
		document.getElementById("parameters07").innerHTML = parameters07;
		
		document.getElementById("parameters04b").innerHTML = parameters04b;
//		document.getElementById("parameters05b").innerHTML = parameters05b;
		document.getElementById("parameters06b").innerHTML = parameters06b;
//		document.getElementById("parameters07b").innerHTML = parameters07b;		
		
//		document.getElementById("parameters08").innerHTML = parameters08;
//		document.getElementById("parameters09").innerHTML = parameters09;
		document.getElementById("parameters0S").innerHTML = parameters0S;
 
 
} else {
parameters02="      <label for='exponentInput'><b>Exponent (n): </b></label><input type='number' id='exponentInput' min='2' max='9999' step='1' value='2'>";
parameters03="<label for='iterationsInput'><b>Iterations to attempt: </b></label><input type='number' id='iterationsInput' min='1' max='300' step='1' value='9'> ";
parameters04="Quadrant I or Orthant rendered IN GLITCH MODE";
parameters04a="";
parameters05="<label for='xInput'><b>Extending rightward to real magnitude: </b></label><input type='number' id='xInput' min='-1000' max='1000' step='.000001' value='2';'>";
parameters06="Quadrant I or Orthant rendered IN GLITCH MODE";
parameters07="<label for='yInput'><b>Extending up from <em>j</em>-axis magnitude: </b></label><input type='number' id='yInput' min='-1000' max='1000' step='.000001' value='0' ;'>";
parameters0S="<label for='outputSizeInput'><b>Orthant size (bigger inputs -> longer render time): </b></label> <input type='number' id='outputSizeInput' min='20' max='2000' step='.5' value='200.5' >"

		document.getElementById("parameters02").innerHTML = parameters02;
		document.getElementById("parameters03").innerHTML = parameters03;
		document.getElementById("parameters04").innerHTML = parameters04;
		document.getElementById("parameters04a").innerHTML = parameters04a;
		document.getElementById("parameters05").innerHTML = parameters05;
		document.getElementById("parameters06").innerHTML = parameters06;
		document.getElementById("parameters07").innerHTML = parameters07;
		document.getElementById("parameters0S").innerHTML = parameters0S;

}
} 
 
var fractGlitch="Fract"; 
var oneOrthantMode=0;
var fourQuadrantBypass=0;
var maxIterations = 100;
var escapeMagnitude =4;
var zoomIndex = 1;
var magFactor = .5*(2**zoomIndex);
//"Default" is a left x value of 2, y of 0, with a magnification of .5. (Double magnification factor to halve scope--or just increment zoomIndex.) Magnification was built for one-orthant mode, so anticipate some possible disorientation in four-orthant mode.
//[[whichFractal values: 1 is Mandelbrot, 3 is Tricorn, 2 is MandelbrotS, 6 is TricornS(cs), 7 is TricornS2(sc), 10 split-complex Mandelbrot, 11 split-complex Tricorn]]
var whichFractal = 8;
var upperLeftX = -.347;
var upperLeftY = .820005;
//range of 2pi for mode2ModuloIterationSelectionParameter (as used, periodic at one pi AKA pi)--try 0-1.57 , multiples of .3925 or .523 or .0157 recommended.
var mode2ModuloIterationSelectionParameter=100*.0157;
var mode2ModuloOffset=maxIterations*(Math.abs(Math.sin(mode2ModuloIterationSelectionParameter)));

//sign values should be 0 or even (n%2=0). "Default" is real 0, im 2 for conventionally oriented complex plane quadrants.
var realOrthantSign = 0;
var imOrthantSign = 2;

//exponent must be positive integer (for now--
let exponent = 4;

var colorMode=2;
var mode3ModuloIterationSelectionParameter=50*.0157;
var mode3ModuloOffset=maxIterations*(Math.abs(Math.sin(mode3ModuloIterationSelectionParameter)));

var mode4ModuloIterationSelectionParameter=75*.0157;
var mode4ModuloOffset=maxIterations*(Math.abs(Math.sin(mode4ModuloIterationSelectionParameter)));

var modulus = 1;
var outputBoxSize = 2000;
var defaultPixelDistance = 1/(outputBoxSize);
var magPixelDistance = defaultPixelDistance/magFactor;

//i changed these from let to var hopefully it doesn't break anything
var realSign = realOrthantSign;
var imSign = imOrthantSign;
var canvasSize=100;

            var output = "<canvas id='myCanvas' width="+canvasSize+" height="+canvasSize+" style='border:1px solid grey'></canvas><a id='download' download='cHex Fractal .jpg' href='' onclick='download_img(this);'>Download to cHex Fractal.jpg</a>";
            var output2= "j";


//const realParts = [upperLeftX];
//const imParts = [upperLeftY];
const realParts = [];
const imParts = [];


const test =[];
const escapeCount=[];
const escapeCount2=[];
const escapeCount3=[];
const escapeCount4=[];


		function metaRender(){

		renderingMessage();
		setTimeout(render, 100);
		setTimeout(renderCompleteMessage, 1000);

}	

		
		
        function render() {

 			escapeCount.length=0;
 			escapeCount2.length=0;
 			escapeCount3.length=0;
 			escapeCount4.length=0;

          
//            whichFractal = Number(document.getElementById("whichFractalInput").value);
			if (whichFractal < 10){
			realSign = Number(document.getElementById("realSignInput").value);
            imSign = Number(document.getElementById("imSignInput").value);
            realOrthantSign = Number(document.getElementById("realSignInput").value);
            imOrthantSign = Number(document.getElementById("imSignInput").value);
			
			
			realSignIII = Number(document.getElementById("realSignInputIII").value);
            imSignIII = Number(document.getElementById("imSignInputIII").value);
            realOrthantSignIII = Number(document.getElementById("realSignInputIII").value);
            imOrthantSignIII = Number(document.getElementById("imSignInputIII").value);
			}

            exponent = Number(document.getElementById("exponentInput").value);
            maxIterations = Number(document.getElementById("iterationsInput").value);
            signQuant = Number(document.getElementById("signQuantInput").value);
            

            

            upperLeftX = Number(document.getElementById("xInput").value);
            realParts[0]=upperLeftX;


            upperLeftY = Number(document.getElementById("yInput").value);
            imParts[0]=upperLeftY;
            zoomIndex = Number(document.getElementById("zoomInput").value);
            magFactor = .5*(2**zoomIndex);
            colorMode = Number(document.getElementById("colorModeInput").value);
            mode2ModuloIterationSelectionParameter = Number(document.getElementById("colorModInput").value)*.0157;
			mode3ModuloIterationSelectionParameter = Number(document.getElementById("colorModInput").value)*.0157;
            mode4ModuloIterationSelectionParameter = Number(document.getElementById("colorModInput").value)*.0157;
            
            if ((zoomIndex>0 || upperLeftX!=2)||(zoomIndex>0 || upperLeftY!=0)){
            outputBoxSize = Number(document.getElementById("outputSizeInput").value)+2;}
            else {
            outputBoxSize = Number(document.getElementById("outputSizeInput").value)+1;}
            
            defaultPixelDistance = 1/(outputBoxSize);
			magPixelDistance = defaultPixelDistance/magFactor;
			mode2ModuloOffset=maxIterations*(Math.abs(Math.sin(mode2ModuloIterationSelectionParameter)));
mode3ModuloOffset=maxIterations*(Math.abs(Math.sin(mode3ModuloIterationSelectionParameter)));
mode4ModuloOffset=maxIterations*(Math.abs(Math.sin(mode4ModuloIterationSelectionParameter)));


            if ((zoomIndex>0 || upperLeftX!=2)||(zoomIndex>0 || upperLeftY!=0)){
            oneOrthantMode=1;
			fourQuadrantBypass=1;
			canvasSize=outputBoxSize;
} else {
            oneOrthantMode=0;
			fourQuadrantBypass=0;
			canvasSize=outputBoxSize*2;
}    

if (whichFractal==1){var fractalLabel="Mandelbrot";} 
if (whichFractal==3){var fractalLabel="Tricorn";}
if (whichFractal==2){var fractalLabel="MandelbrotS";}
if (whichFractal==6){var fractalLabel="TricornCS";}
if (whichFractal==7){var fractalLabel="TricornSC";}
if (whichFractal==10){var fractalLabel="splitMandelbrot"; realSign="pltCm"; imSign="pltCm"; realSignIII=-1; imSignIII=-1;}
if (whichFractal==11){var fractalLabel="splitTricorn"; realSign="pltCm"; imSign="pltCm"; realSignIII=-1; imSignIII=-1;}

	let filename = "cMulti"+fractGlitch+" "+signQuant+"signs"+" I s"+realSign+"s"+imSign+" "+"III s"+realSignIII+"s"+imSignIII+" "+fractalLabel+" "+exponent+"  x"+upperLeftX+" y"+upperLeftY+" itr"+maxIterations+" mode"+colorMode+" mod"+mode2ModuloIterationSelectionParameter/.0157+" "+" zm"+zoomIndex;

            output = "<canvas id='myCanvas' width="+(canvasSize-1)+" height="+(canvasSize-1)+" style='border:1px solid grey'></canvas><br><a id='download' download='"+filename+".jpg' href='' onclick='download_img(this);'>Download this image named with its parameters</a>";
            
            
            
 if ((upperLeftX<2 && zoomIndex<upperLeftX**-1)||(upperLeftY<0 )){
             output2 = "Warning: this rendering might be inaccurate due to possible imbalance between zoom and axis proximity or axis crossing.<br>To end warning, increase zoom or extend deeper into the target orthant.<br><canvas id='zoomCanvas' width="+(canvasSize-2)+" height="+(canvasSize-2)+" style='border:1px solid grey'></canvas><br><a id='download' download='"+filename+".jpg' href='' onclick='download_img(this);'>Download this image named with its parameters</a>";
            
            let output3 = "<a id='download' download='"+filename+".jpg' href='' onclick='download_img(this);'>Download this image named with its parameters</a>";
            
}            else {
            output2 = "<canvas id='zoomCanvas' width="+(canvasSize-2)+" height="+(canvasSize-2)+" style='border:1px solid grey'></canvas><br><a id='download' download='"+filename+".jpg' href='' onclick='download_img(this);'>Download this image named with its parameters</a>";
            
            let output3 = "<a id='download' download='"+filename+".jpg' href='' onclick='download_img(this);'>Download this image named with its parameters</a>";
}

            if ((zoomIndex>0 || upperLeftX!=2)||(zoomIndex>0 || upperLeftY!=0)){
            oneOrthantMode=1;
			fourQuadrantBypass=1;
			canvasSize=outputBoxSize;
			            let output3 = "<a id='download' download='"+filename+".jpg' href='' onclick='download_img(this);'>Download this image named with its parameters</a>";
			document.getElementById("result").innerHTML = output2;
			document.getElementById("downloadEZ").innerHTML = output3;
			computeEscapes();
			oneOrthantRender();
} else {
            oneOrthantMode=0;
			fourQuadrantBypass=0;
			canvasSize=outputBoxSize*2;
			            let output3 = "<a id='download' download='"+filename+".jpg' href='' onclick='download_img(this);'>Download this image named with its parameters</a>";
			document.getElementById("result").innerHTML = output;
			document.getElementById("downloadEZ").innerHTML = output3;
			computeEscapes();
			fourQuadrantRender();
}    



        }
 
        
  //BEGIN FUNCTION DECLARATIONS


function consolidate(a,b,c,d,e,f,g,h){
//a,c,e,g must be 0 if mod2, i.e. even or 0
	const consolidArray=[];
	let realSign=0;
	let imSign=0;
	let realMag=0;
	let imMag=0;

	if (a==e){
		realMag=b+f;
	} else {
		realMag=Math.abs(b-f);
}

	if (c==g){
		imMag=d+h;
	} else {
		imMag=Math.abs(d-h);
}

	if (a==e && (b+f) != 0){
	realSign=a;	
	}
	
	if(b>f){
	realSign=a;
} 	

	if (f>b){
	realSign=e;
} 	

	if (b+f==0){
	realSign=0;	
}

	if (c==g && (d+h) != 0){
	imSign=c;	
	}
	
	if(d>h){
	imSign=c;
} 	

	if (h>d){
	imSign=g;
} 	

	if (d+h==0){
	imSign=0;	
}

	consolidArray.push(realSign,realMag,imSign,imMag);

consolid=consolidArray;

return consolid;
}	



function fmpMultiply(a,b,c,d,e){
//a,c must be even or 0, twice the sign index (e.g., identity=0, sequitive=2, trinitive=4, quadritive=6, etc.). e is the quantity of signs of the multipolar system.
	const productArray=[];
	let realSign1=0;
	let realSign2=0;
	let realMag1=0;
	let realMag2=0;
	let productMag=0;
	let productSign=0;

	if (b == 0 || d==0){
	productSign=0;
	} else {
	productSign=(a+c)%(2*e);
	}

	productMag=b*d;

	productArray.push(productSign,productMag);

Product = productArray;

return Product;
}


function fmpConjugate(a,b,c,d,e){
//a,c must be even or 0
//e is the quantity of signs in the multipolar system
	let newImSign=(c+e)%(2*e);
	const outputArray=[a,b,newImSign,d];
	
return outputArray;
}


function splitConjugate(a,b){
//
	b=b*-1;
	const outputArray=[a,b];
	
return outputArray;
}


function fmpComplexMultiply(a,b,c,d,e,f,g,h,i){
//a,c,e,g must be 0 if mod2, i.e. even or 0
//i is the quantity of signs in the multipolar system
	const productArray=[];
	const productArray1=[];
	const productArray2=[];
	const consolidArray2=[];
	const productArray3=[];
	let productRealSign=0;
	let productImSign=0;
	let productRealMag=0;
	let productImMag=0;
	
//First, Last...
	productArray1.push(...fmpMultiply(a,b,e,f,i));
	productArray1.push(...fmpMultiply(c,d,e,f,i));
	productArray2.push(...fmpMultiply(c,d,g+2,h,i));
	productArray2.push(...fmpMultiply(a,b,g,h,i));
	const consolidArray1=productArray1.concat(...productArray2);
	consolidArray2.push(...consolidate(...consolidArray1));

fmpProduct = consolidArray2;

return fmpProduct;
console.log(" " +  "prduct " + fmpProduct);
}		

function splitMultiply(a,b,c,d){
	const consolidArray2=[];
	let productRealMag=(a*c)+(b*d);
	let productImMag=(a*d)+(b*c);
	
//First, Last...
	consolidArray2.push(productRealMag, productImMag);

splitProduct = consolidArray2;

return splitProduct;
}	


function splitExponentiate(a,b,e){
////e is exponent, must be positive integer greater than two (for now). 

	const realMag=[a];
	const imMag=[b];
	const productArray=[];
	const factorArray=[];
	const splitProduct=[];

for  (let i = 0; i < e-1; i++){
	
	let realMag01=realMag[i];
	let imMag01=imMag[i];
	
	productArray.push(...splitMultiply(a,b,realMag01,imMag01));
	
	realMag.push(productArray[(i*2)]);
	imMag.push(productArray[(i*2)+1]);

}

	arrayLength=productArray.length;
	
	
	let outputMag=productArray[arrayLength-2];
	let outputMag2=productArray[arrayLength-1];
splitProduct.push(outputMag,outputMag2);
//console.log(splitProduct);
return splitProduct;
}	


function fmpNaturalExponent(a,b,c,d,e,f){
//a,c must be even or 0
//e is the quantity of signs in the multipolar system > 1
////f is exponent, must be positive integer or zero. a,c are signs expressed as even exponents of s. b, d are magnitudes.

	const realSign=[a];
	const realMag=[b];
	const imSign=[c];
	const imMag=[d];
	const productArray=[];
	const factorArray=[];
	const Product=[];

//IF F==0, IF F==1...

	if (f==0){
	
		let outputSign=0;
		let outputMag=1;
		let outputSign2=0;
		let outputMag2=0;
		Product.push(outputSign,outputMag,outputSign2,outputMag2);
}

	if (f==1){
	
		let outputSign=a;
		let outputMag=b;
		let outputSign2=c;
		let outputMag2=d;
		Product.push(outputSign,outputMag,outputSign2,outputMag2);
}

	if (f>1){
for  (let i = 0; i < f-1; i++){
	
	let realSign01=realSign[i];
	let realMag01=realMag[i];
	let imSign01=imSign[i];
	let imMag01=imMag[i];
	
	productArray.push(...fmpComplexMultiply(a,b,c,d,realSign01,realMag01,imSign01,imMag01,e));
	
	realSign.push(productArray[(i*4)]);
	realMag.push(productArray[(i*4)+1]);
	imSign.push(productArray[(i*4)+2]);
	imMag.push(productArray[(i*4)+3]);

}

	arrayLength=productArray.length;
	
	
	let outputSign=productArray[arrayLength-4];
	let outputMag=productArray[arrayLength-3];
	let outputSign2=productArray[arrayLength-2];
	let outputMag2=productArray[arrayLength-1];
Product.push(outputSign,outputMag,outputSign2,outputMag2);
}
//console.log("Product:" + Product);
return Product;
}		



function fmpCosSin(a,b,e){
//a is the cycle of exponentiation
//b is the argument
//e is the quantity of signs in the multipolar system > 1
//outputs 0 for orthants that a signed s under repeat self-multiplication bypasses


	let argumentNose=b%Math.PI;
	let csRealMag=Math.abs(Math.cos(argumentNose));
	let csImMag=Math.sin(argumentNose);
	let orthantCount=((Math.floor(b/(Math.PI/2)))%(e*2))+1;


const map01 = new Map([
  ["a", 2+"-"+3],
  ["b", 430],
  ["c", 24]
]);

	for (let i=0; i<(e/2);i++){
		for (let j=0; j<(e*2)+1;j++){

//if j==0, if j%2==0 && j!=0, if j%2!=0

	if (j==0){
	map01.set(0+"-"+0, 1+"-"+1);	
	
}
	
	if (j%2==0 && j!=0){
		const product1=fmpNaturalExponent(0,0,(i*2),1,e,j);
		const product2=fmpNaturalExponent(0,0,(i*2),1,e,(j-1));
		let realProductSign = product1[0];
		let imaginaryProductSign = product2[2];
//console.log(i +"j"+ j+"realProductSign"+realProductSign+" "+imaginaryProductSign);
map01.set(((i*2)+1)+"-"+j, realProductSign+"-"+imaginaryProductSign);
	
	
	if (i==((e/2)-2) && j>3){
	j=(e*2);
}
}


	if (j%2!=0){
		const product1=fmpNaturalExponent(0,0,(i*2),1,e,(j-1));
		const product2=fmpNaturalExponent(0,0,(i*2),1,e,j);
		let realProductSign = product1[0];
		let imaginaryProductSign = product2[2];
//console.log(i +"j"+ j+"realProductSign"+realProductSign+" "+imaginaryProductSign);
map01.set(((i*2)+1)+"-"+j, realProductSign+"-"+imaginaryProductSign);

	if (i==((e/2)-2) && j>3){
	j=(e*2);
}


}

}
}

const numb = map01.get(a+"-"+orthantCount);
console.log(numb);
//document.getElementById("demo").innerHTML = "There are " + numb + " apples.";


	if (numb != undefined){
//write a thing that parses numb 
		const signsArray = numb.split('-');
		signsArray[0]=Number(signsArray[0]);
		signsArray[1]=Number(signsArray[1]);

		if (csRealMag==0){
		var csRealSign=0;
} else {
		var csRealSign=signsArray[0];

}
	
	if (csImMag==0){
		var csImSign=0;
} else {
		var csImSign=signsArray[1];		
}



		const sinCosArray=[csRealSign,csRealMag,csImSign,csImMag];
		return sinCosArray;
} else {
const signsArray = [0,0];
const sinCosArray=[signsArray[0],0,signsArray[1],0];
return sinCosArray;
}

}


function fmpArgument(a,b,c,d,e){
//a,c must be even or 0
//e is the quantity of signs in the multipolar system > 1
//if b or d is zero this function defaults to the s^1 cycle.
//output [cycle of exponentiation, argument (angle) magnitude in radians]

	if (b==0){
		a=c;
}

	if (d==0){
		c=a;
}


	const exponentiationCycle = fmpExponentiationCycle(a,b,c,d,e);

	if (exponentiationCycle[0] != 0){

		let countOfTraversedOrthants=(exponentiationCycle[1]-1);
			if (countOfTraversedOrthants == -1){
			countOfTraversedOrthants = 0;	}	
		
		
			let tail = countOfTraversedOrthants*Math.PI/2;
//console.log(tail);

			if (exponentiationCycle[1]%2==1){
				var nose=Math.atan2(d, b);
//console.log("nose"+nose);				
} else {
				var nose=Math.atan2(d, -b)-(Math.PI/2);
//console.log("nose"+nose);		
}

	const argumentArray=[exponentiationCycle[0], tail+nose];	
	return argumentArray;
		
}

	if (exponentiationCycle[0] == 0){
		const argumentArray=[0, 0];	
		return argumentArray;
	}
}


function fmpMandelbrot(a,b,c,d,e,f,g){
//accepts complex hexapolar, exponent (e.g., minimum z^2 but could be z^e  if e is positive integer)
//f is the maximum number of iterations
//g is the quantity of signs in the system
//console.log(a,b,c,d,e,f);
	const newZArray=[a,b,c,d];
	let escapeCount=0;
	let zRealSign=newZArray[0];
	let zRealMag=newZArray[1];
	let zImSign=newZArray[2];		
	let zImMag=newZArray[3];
	let tooBig=0;
	
for  (let i = 0; i < f+1 && tooBig <=escapeMagnitude; i++){
	
	zRealSign=newZArray[(i*4)];
	zRealMag=newZArray[(i*4)+1];
	zImSign=newZArray[(i*4)+2];		
	zImMag=newZArray[(i*4)+3];
	
	if (modulus == 0){

//const conjArray=[];
//conjArray.push(cHexConjugate(zRealSign,zRealMag,zImSign,zImMag));

const conjProductArray=[];
let zImSignConj = (zImSign+g)%(g*2);
conjProductArray.push(...fmpComplexMultiply(zRealSign,zRealMag,zImSign,zImMag,zRealSign,zRealMag,zImSignConj,zImMag,g));


//console.log(conjProductArray.toString());

	tooBig=conjProductArray[1];

} else if (modulus == 1){
	
const conjProductArray=[];
let zImSignConj = (zImSign+g)%(g*2);
conjProductArray.push(...fmpComplexMultiply(zRealSign,zRealMag,zImSign,zImMag,zRealSign,zRealMag,zImSignConj,zImMag,g));


//console.log(i, conjProductArray.toString());

	if (conjProductArray[0] == 0){
	tooBig=conjProductArray[1];
} else {
	tooBig=0;
}
	
	
	
} else {
	tooBig=(zRealMag**2)+(zImMag**2);
}

newZArray.push(...consolidate(...fmpNaturalExponent(zRealSign,zRealMag,zImSign,zImMag,g,e),a,b,c,d));

//these newZ array values might come in handy for a Buddhabrot variation...

	escapeCount=i;
//console.log(escapeCount);
}
//console.log(escapeCount);
return escapeCount;
//return zRealSign;

}


function splitMandelbrot(a,b,e,f){
//accepts split complex, exponent (e.g., minimum z^2 but could be z^e  if e is positive integer)
//f is the maximum number of iterations

	const newZArray=[a,b];
	let escapeCount=0;
	let zRealMag=newZArray[0];
	let zImMag=newZArray[1];
	let tooBig=0;
	
for  (let i = 0; i < f+1 && tooBig <=escapeMagnitude; i++){
	
	zRealMag=newZArray[(i*2)];
	zImMag=newZArray[(i*2)+1];
	
		
const conjProductArray2=[];
conjProductArray2.push(...splitMultiply(...splitConjugate(zRealMag,zImMag),zRealMag,zImMag));


//console.log(conjProductArray2.toString());

	if (conjProductArray2[0] > 0){
	tooBig=conjProductArray2[0];
} else {
	tooBig=0;
}
	
	const splitArray=[];
	splitArray.push(...splitExponentiate(zRealMag,zImMag,e));

	let indicatorLen=splitArray.length-2;
//console.log(indicatorLen);

	newZArray.push(splitArray[indicatorLen]+a,splitArray[indicatorLen+1]+b);
	
//these newZ array values might come in handy for a Buddhabrot variation...

	escapeCount=i;

}
return escapeCount;
//return zRealSign;
}

function fmpMandelbrotS(a,b,c,d,e,f,g){
//accepts complex hexapolar, exponent (e.g., minimum z^2 but could be z^e  if e is positive integer)
//f is the maximum number of iterations

	const newZArray=[a,b,c,d];
	let escapeCount=0;
	let zRealSign=newZArray[0];
	let zRealMag=newZArray[1];
	let zImSign=newZArray[2];		
	let zImMag=newZArray[3];
	let tooBig=0;
	
for  (let i = 0; i < f+1 && tooBig <=escapeMagnitude; i++){
	
	zRealSign=newZArray[(i*4)];
	zRealMag=newZArray[(i*4)+1];
	zImSign=newZArray[(i*4)+2];		
	zImMag=newZArray[(i*4)+3];
	
	if (modulus == 0){

//const conjArray=[];
//conjArray.push(cHexConjugate(zRealSign,zRealMag,zImSign,zImMag));

const conjProductArray=[];
let zImSignConj = (zImSign+g)%(g*2);
conjProductArray.push(...fmpComplexMultiply(zRealSign,zRealMag,zImSign,zImMag,zRealSign,zRealMag,zImSignConj,zImMag,g));


//console.log(conjProductArray.toString());

	tooBig=conjProductArray[1];

} else if (modulus == 1){
	
const conjProductArray=[];
let zImSignConj = (zImSign+g)%(g*2);
conjProductArray.push(...fmpComplexMultiply(zRealSign,zRealMag,zImSign,zImMag,zRealSign,zRealMag,zImSignConj,zImMag,g));


//console.log(conjProductArray.toString());

	if (conjProductArray[0] == 0){
	tooBig=conjProductArray[1];
} else {
	tooBig=0;
}
	
	
	
} else {
	tooBig=(zRealMag**2)+(zImMag**2);
}

newZArray.push(...consolidate(...fmpNaturalExponent(...fmpComplexMultiply(0,0,0,1,zRealSign,zRealMag,zImSign,zImMag,g),g,e),a,b,c,d));

//these newZ array values might come in handy for a Buddhabrot variation...

	escapeCount=i;

}
return escapeCount;

//return zRealSign;
}


function fmpTricorn(a,b,c,d,e,f,g){
//accepts complex hexapolar, exponent (e.g., minimum z^2 but could be z^e  if e is positive integer)
//f is the maximum number of iterations

	const newZArray=[a,b,c,d];
	let escapeCount=0;
	let zRealSign=newZArray[0];
	let zRealMag=newZArray[1];
	let zImSign=newZArray[2];		
	let zImMag=newZArray[3];
	let tooBig=0;
	
for  (let i = 0; i < f+1 && tooBig <=escapeMagnitude; i++){
	
	zRealSign=newZArray[(i*4)];
	zRealMag=newZArray[(i*4)+1];
	zImSign=((newZArray[(i*4)+2])+g)%(g*2);		
	zImMag=newZArray[(i*4)+3];
	
	if (modulus == 0){

//const conjArray=[];
//conjArray.push(cHexConjugate(zRealSign,zRealMag,zImSign,zImMag));

const conjProductArray=[];
let zImSignConj = (zImSign+g)%(g*2);
conjProductArray.push(...fmpComplexMultiply(zRealSign,zRealMag,zImSign,zImMag,zRealSign,zRealMag,zImSignConj,zImMag,g));


//console.log(conjProductArray.toString());

	tooBig=conjProductArray[1];

} else if (modulus == 1){
	
const conjProductArray=[];
let zImSignConj = (zImSign+g)%(g*2);
conjProductArray.push(...fmpComplexMultiply(zRealSign,zRealMag,zImSign,zImMag,zRealSign,zRealMag,zImSignConj,zImMag,g));


//console.log(conjProductArray.toString());

	if (conjProductArray[0] == 0){
	tooBig=conjProductArray[1];
} else {
	tooBig=0;
}
	
	
	
} else {
	tooBig=(zRealMag**2)+(zImMag**2);
}

newZArray.push(...consolidate(...fmpNaturalExponent(zRealSign,zRealMag,zImSign,zImMag,g,e),a,b,c,d,signQuant));

//these newZ array values might come in handy for a Buddhabrot variation...

	escapeCount=i;

}
return escapeCount;
//return zRealSign;
}


function splitTricorn(a,b,e,f){
//accepts split complex, exponent (e.g., minimum z^2 but could be z^e  if e is positive integer)
//f is the maximum number of iterations

	const newZArray=[a,b];
	let escapeCount=0;
	let zRealMag=newZArray[0];
	let zImMag=newZArray[1];
	let tooBig=0;
	
for  (let i = 0; i < f+1 && tooBig <=escapeMagnitude; i++){
	
	zRealMag=newZArray[(i*2)];
	zImMag=newZArray[(i*2)+1];
	
		
const conjProductArray2=[];
conjProductArray2.push(...splitMultiply(...splitConjugate(zRealMag,zImMag),zRealMag,zImMag));


//console.log(conjProductArray2.toString());

	if (conjProductArray2[0] > 0){
	tooBig=conjProductArray2[0];
} else {
	tooBig=0;
}
	
	const splitArray=[];
	splitArray.push(...splitExponentiate(zRealMag,-zImMag,e));

	let indicatorLen=splitArray.length-2;
//console.log(indicatorLen);

	newZArray.push(splitArray[indicatorLen]+a,splitArray[indicatorLen+1]+b);
	
//these newZ array values might come in handy for a Buddhabrot variation...

	escapeCount=i;

}
return escapeCount;
//return zRealSign;
}


function fmpTricornCS(a,b,c,d,e,f,g){
//accepts complex hexapolar, exponent (e.g., minimum z^2 but could be z^e  if e is positive integer)
//f is the maximum number of iterations

	const newZArray=[a,b,c,d];
	let escapeCount=0;
	let zRealSign=newZArray[0];
	let zRealMag=newZArray[1];
	let zImSign=newZArray[2];		
	let zImMag=newZArray[3];
	let tooBig=0;
	
for  (let i = 0; i < f+1 && tooBig <=escapeMagnitude; i++){
	
	zRealSign=newZArray[(i*4)];
	zRealMag=newZArray[(i*4)+1];
	zImSign=((newZArray[(i*4)+2])+g)%(g*2);		
	zImMag=newZArray[(i*4)+3];
	
	if (modulus == 0){

//const conjArray=[];
//conjArray.push(cHexConjugate(zRealSign,zRealMag,zImSign,zImMag));

const conjProductArray=[];
let zImSignConj = (zImSign+g)%(g*2);
conjProductArray.push(...fmpComplexMultiply(zRealSign,zRealMag,zImSign,zImMag,zRealSign,zRealMag,zImSignConj,zImMag,g));


//console.log(conjProductArray.toString());

	tooBig=conjProductArray[1];

} else if (modulus == 1){
	
const conjProductArray=[];
let zImSignConj = (zImSign+g)%(g*2);
conjProductArray.push(...fmpComplexMultiply(zRealSign,zRealMag,zImSign,zImMag,zRealSign,zRealMag,zImSignConj,zImMag,g));


//console.log(conjProductArray.toString());

	if (conjProductArray[0] == 0){
	tooBig=conjProductArray[1];
} else {
	tooBig=0;
}
	
	
	
} else {
	tooBig=(zRealMag**2)+(zImMag**2);
}

newZArray.push(...consolidate(...fmpNaturalExponent(...fmpComplexMultiply(0,0,0,1,zRealSign,zRealMag,zImSign,zImMag,g),g,e),a,b,c,d));

//these newZ array values might come in handy for a Buddhabrot variation...

	escapeCount=i;

}
return escapeCount;
//return zRealSign;
}


function fmpTricornSC(a,b,c,d,e,f,g){
//accepts complex hexapolar, exponent (e.g., minimum z^2 but could be z^e  if e is positive integer)
//f is the maximum number of iterations

	const newZArray=[a,b,c,d];
	let escapeCount=0;
	let zRealSign=newZArray[0];
	let zRealMag=newZArray[1];
	let zImSign=newZArray[2];		
	let zImMag=newZArray[3];
	let tooBig=0;
	
for  (let i = 0; i < f+1 && tooBig <=escapeMagnitude; i++){
	
	zRealSign=((newZArray[(i*4)+2])+2)%(g*2);
	zRealMag=newZArray[(i*4)+3];
	zImSign=((newZArray[(i*4)])+g)%(g*2);		
	zImMag=newZArray[(i*4)+1];
	
	if (modulus == 0){

//const conjArray=[];
//conjArray.push(cHexConjugate(zRealSign,zRealMag,zImSign,zImMag));

const conjProductArray=[];
let zImSignConj = (zImSign+g)%(g*2);
conjProductArray.push(...fmpComplexMultiply(zRealSign,zRealMag,zImSign,zImMag,zRealSign,zRealMag,zImSignConj,zImMag,g));


//console.log(conjProductArray.toString());

	tooBig=conjProductArray[1];

} else if (modulus == 1){
	
const conjProductArray=[];
let zImSignConj = (zImSign+g)%(g*2);
conjProductArray.push(...fmpComplexMultiply(zRealSign,zRealMag,zImSign,zImMag,zRealSign,zRealMag,zImSignConj,zImMag,g));


//console.log(conjProductArray.toString());

	if (conjProductArray[0] == 0){
	tooBig=conjProductArray[1];
} else {
	tooBig=0;
}
	
	
	
} else {
	tooBig=(zRealMag**2)+(zImMag**2);
}

newZArray.push(...consolidate(...fmpNaturalExponent(zRealSign,zRealMag,zImSign,zImMag,g,e),a,b,c,d));

//these newZ array values might come in handy for a Buddhabrot variation...

	escapeCount=i;

}
return escapeCount;
//return zRealSign;
}



let text = "";


function computeEscapes(){

console.log("computeEscapes called; outputBoxSize:" + outputBoxSize + " whichFractal:" + whichFractal + " realOrthantSign:" + realOrthantSign + "  imOrthantSign:" + imOrthantSign + " ");
let i= 0;
while (i < outputBoxSize) {
  text += "<br>The number is " + i;
  realParts[i+1]=realParts[i] - magPixelDistance;
  imParts[i+1]=imParts[i] + magPixelDistance;
  i++;
}


for(let j = 0; j < outputBoxSize; j++){
  for(let k = 0; k < outputBoxSize; k++){
//pull jth realParts value (realMag) and use outputBoxSize times with kth imParts value.
  realMag =realParts[j];
  imMag = imParts[k];

//console.log(realMag+' '+imMag);

//add pixel escape number to escapeCount array such that every outputBoxSize is a new row

	const realMagArray=[realMag];
	const imMagArray=[imMag];
	const realSignArray=[realOrthantSign];
	const imSignArray=[imOrthantSign];
	let   largestComponent = 0;
///the real recursive right here


	if (whichFractal == 1){
escapeCount.push(fmpMandelbrot(realOrthantSign,realMag,imOrthantSign,imMag,exponent,maxIterations,signQuant));

//console.log(realOrthantSign,realMag,imOrthantSign,imMag);
//console.log(Mandelbrot(realOrthantSign,realMag,imOrthantSign,imMag,exponent,maxIterations));

	if (oneOrthantMode != 1){
//given a pair of orthant signs, three others each s^3 rotated

/*
		if ((realOrthantSign == 8 && imOrthantSign == 8)||(realOrthantSign == 0 && imOrthantSign == 4)){
			var orthant2RealSign=6;
			var orthant2RealMag=1;
			var orthant2imSign=0;
			var orthant2imMag=0;
			
			var orthant3RealSign=0;
			var orthant3RealMag=0;
			var orthant3imSign=0;
			var orthant3imMag=1;
			
			var orthant4RealSign=0;
			var orthant4RealMag=0;
			var orthant4imSign=6;
			var orthant4imMag=1;
		} else if ((realOrthantSign == 0 && imOrthantSign == 0)||(realOrthantSign == 4 && imOrthantSign == 8)){
//symmetry for Mandelbrot
			var orthant2RealSign=0;
			var orthant2RealMag=0;
			var orthant2imSign=4;
			var orthant2imMag=1;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=0;
			var orthant4imSign=10;
			var orthant4imMag=1;
		} 
		
		if (((realOrthantSign == 0 && imOrthantSign == 2)||(realOrthantSign == 4 && imOrthantSign == 6))||((realOrthantSign == 8 && imOrthantSign == 10)||(realOrthantSign == 1 && imOrthantSign == 1))) {
			var orthant2RealSign=0;
			var orthant2RealMag=0;
			var orthant2imSign=2;
			var orthant2imMag=1;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=0;
			var orthant4imSign=8;
			var orthant4imMag=1;
		}

	if ((((realOrthantSign == 0 && imOrthantSign == 6)||(realOrthantSign == 0 && imOrthantSign == 8))||((realOrthantSign == 0 && imOrthantSign == 10)||(realOrthantSign == 2 && imOrthantSign == 0)))||(((realOrthantSign == 4 && imOrthantSign == 0)||(realOrthantSign == 1 && imOrthantSign == 1))||((realOrthantSign == 1 && imOrthantSign == 1)||(realOrthantSign == 1 && imOrthantSign == 1)))){ */
			var orthant2RealSign=6;
			var orthant2RealMag=1;
			var orthant2imSign=0;
			var orthant2imMag=0;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=1;
			var orthant4imSign=0;
			var orthant4imMag=0;
//}


	const orthant2=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant2RealSign,orthant2RealMag,orthant2imSign,orthant2imMag,signQuant);
		const orthant3=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant3RealSign,orthant3RealMag,orthant3imSign,orthant3imMag,signQuant);
			const orthant4=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant4RealSign,orthant4RealMag,orthant4imSign,orthant4imMag,signQuant);


escapeCount2.push(fmpMandelbrot(realSignIII,realMag,imSign,imMag,exponent,maxIterations,signQuant));
escapeCount3.push(fmpMandelbrot(realSignIII,realMag,imSignIII,imMag,exponent,maxIterations,signQuant));
escapeCount4.push(fmpMandelbrot(orthant4[0],realMag,imSignIII,imMag,exponent,maxIterations,signQuant));
}
} else if (whichFractal == 3){

escapeCount.push(fmpTricorn(realOrthantSign,realMag,imOrthantSign,imMag,exponent,maxIterations,signQuant));

	if (oneOrthantMode != 1){
//given a pair of orthant signs, three others each s^3 rotated
//...except for these four four-orthant sets

/*
		if ((realOrthantSign == 8 && imOrthantSign == 8)||(realOrthantSign == 0 && imOrthantSign == 4)){
//symmetry for Tricorn
			var orthant2RealSign=0;
			var orthant2RealMag=0;
			var orthant2imSign=0;
			var orthant2imMag=1;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=0;
			var orthant4imSign=6;
			var orthant4imMag=1;
		} else if ((realOrthantSign == 0 && imOrthantSign == 0)||(realOrthantSign == 4 && imOrthantSign == 8)){
			var orthant2RealSign=0;
			var orthant2RealMag=0;
			var orthant2imSign=4;
			var orthant2imMag=1;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=0;
			var orthant4imSign=10;
			var orthant4imMag=1;
		} else {
			var orthant2RealSign=0;
			var orthant2RealMag=0;
			var orthant2imSign=2;
			var orthant2imMag=1;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=0;
			var orthant4imSign=8;
			var orthant4imMag=1;
		}
}*/

			var orthant2RealSign=6;
			var orthant2RealMag=1;
			var orthant2imSign=0;
			var orthant2imMag=0;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=1;
			var orthant4imSign=0;
			var orthant4imMag=0;
}
	const orthant2=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant2RealSign,orthant2RealMag,orthant2imSign,orthant2imMag,signQuant);
		const orthant3=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant3RealSign,orthant3RealMag,orthant3imSign,orthant3imMag,signQuant);
			const orthant4=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant4RealSign,orthant4RealMag,orthant4imSign,orthant4imMag,signQuant);


escapeCount2.push(fmpTricorn(realSignIII,realMag,imSign,imMag,exponent,maxIterations,signQuant));
escapeCount3.push(fmpTricorn(realSignIII,realMag,imSignIII,imMag,exponent,maxIterations,signQuant));
escapeCount4.push(fmpTricorn(orthant4[0],realMag,imSignIII,imMag,exponent,maxIterations,signQuant));


}

	if (whichFractal==2){
//ie if whichFractal is MandelbrotS
escapeCount.push(fmpMandelbrotS(realOrthantSign,realMag,imOrthantSign,imMag,exponent,maxIterations,signQuant));

	if (oneOrthantMode != 1){

/*
			var orthant2RealSign=0;
			var orthant2RealMag=0;
			var orthant2imSign=2;
			var orthant2imMag=1;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=0;
			var orthant4imSign=8;
			var orthant4imMag=1;
		
	if ((((realOrthantSign == 0 && imOrthantSign == 0)||(realOrthantSign == 8 && imOrthantSign == 6))||(realOrthantSign == 8 && imOrthantSign == 8)||(realOrthantSign == 10 && imOrthantSign == 8)) || (((realOrthantSign == 8 && imOrthantSign == 10)||(realOrthantSign == 8 && imOrthantSign == 6))||(realOrthantSign == 10 && imOrthantSign == 10)||(realOrthantSign == 0 && imOrthantSign == 10))){
			var orthant2RealSign=6;
			var orthant2RealMag=1;
			var orthant2imSign=0;
			var orthant2imMag=0;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=1;
			var orthant4imSign=0;
			var orthant4imMag=0; 
			*/
			
			var orthant2RealSign=6;
			var orthant2RealMag=1;
			var orthant2imSign=0;
			var orthant2imMag=0;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=1;
			var orthant4imSign=0;
			var orthant4imMag=0;
	


//conjugate quadrant 4...

	const orthant2=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant2RealSign,orthant2RealMag,orthant2imSign,orthant2imMag,signQuant);
		const orthant3=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant3RealSign,orthant3RealMag,orthant3imSign,orthant3imMag,signQuant);
			const orthant4=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant4RealSign,orthant4RealMag,orthant4imSign,orthant4imMag,signQuant);


escapeCount2.push(fmpMandelbrotS(realSignIII,realMag,imSign,imMag,exponent,maxIterations,signQuant));
escapeCount3.push(fmpMandelbrotS(realSignIII,realMag,imSignIII,imMag,exponent,maxIterations,signQuant));
escapeCount4.push(fmpMandelbrotS(orthant4[0],realMag,imSignIII,imMag,exponent,maxIterations,signQuant));
}

}

	if (whichFractal==6){
//ie if whichFractal is TricornCS
escapeCount.push(fmpTricornCS(realOrthantSign,realMag,imOrthantSign,imMag,exponent,maxIterations,signQuant));

	if (oneOrthantMode != 1){
				var orthant2RealSign=signQuant;
			var orthant2RealMag=1;
			var orthant2imSign=0;
			var orthant2imMag=0;
			
			var orthant3RealSign=realSignIII;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=1;
			var orthant4imSign=0;
			var orthant4imMag=0;
	

/*
			var orthant2RealSign=0;
			var orthant2RealMag=0;
			var orthant2imSign=2;
			var orthant2imMag=1;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=0;
			var orthant4imSign=8;
			var orthant4imMag=1;
		
	if ((((realOrthantSign == 0 && imOrthantSign == 0)||(realOrthantSign == 8 && imOrthantSign == 6))||(realOrthantSign == 8 && imOrthantSign == 8)||(realOrthantSign == 10 && imOrthantSign == 8)) || (((realOrthantSign == 8 && imOrthantSign == 10)||(realOrthantSign == 8 && imOrthantSign == 6))||(realOrthantSign == 10 && imOrthantSign == 10)||(realOrthantSign == 0 && imOrthantSign == 10))){
			var orthant2RealSign=6;
			var orthant2RealMag=1;
			var orthant2imSign=0;
			var orthant2imMag=0;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=1;
			var orthant4imSign=0;
			var orthant4imMag=0;
			*/
			



//conjugate quadrant 4...

	const orthant2=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant2RealSign,orthant2RealMag,orthant2imSign,orthant2imMag,signQuant);
		const orthant3=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant3RealSign,orthant3RealMag,orthant3imSign,orthant3imMag,signQuant);
			const orthant4=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant4RealSign,orthant4RealMag,orthant4imSign,orthant4imMag,signQuant);


escapeCount2.push(fmpTricornCS(realSignIII,realMag,imSign,imMag,exponent,maxIterations,signQuant));
escapeCount3.push(fmpTricornCS(realSignIII,realMag,imSignIII,imMag,exponent,maxIterations,signQuant));
escapeCount4.push(fmpTricornCS(orthant4[0],realMag,imSignIII,imMag,exponent,maxIterations,signQuant));
}

}


	if (whichFractal==7){
//ie if whichFractal is TricornS2
escapeCount.push(fmpTricornSC(realOrthantSign,realMag,imOrthantSign,imMag,exponent,maxIterations,signQuant));

	if (oneOrthantMode != 1){

						var orthant2RealSign=signQuant;
			var orthant2RealMag=1;
			var orthant2imSign=0;
			var orthant2imMag=0;
			
			var orthant3RealSign=realSignIII;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=1;
			var orthant4imSign=0;
			var orthant4imMag=0;
	

/*
			var orthant2RealSign=0;
			var orthant2RealMag=0;
			var orthant2imSign=2;
			var orthant2imMag=1;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=0;
			var orthant4imSign=8;
			var orthant4imMag=1;
		
	if ((((realOrthantSign == 0 && imOrthantSign == 0)||(realOrthantSign == 8 && imOrthantSign == 6))||(realOrthantSign == 8 && imOrthantSign == 8)||(realOrthantSign == 10 && imOrthantSign == 8)) || (((realOrthantSign == 8 && imOrthantSign == 10)||(realOrthantSign == 8 && imOrthantSign == 6))||(realOrthantSign == 10 && imOrthantSign == 10)||(realOrthantSign == 0 && imOrthantSign == 10))){
			var orthant2RealSign=6;
			var orthant2RealMag=1;
			var orthant2imSign=0;
			var orthant2imMag=0;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=1;
			var orthant4imSign=0;
			var orthant4imMag=0;
	}
*/

//conjugate quadrant 4...

	const orthant2=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant2RealSign,orthant2RealMag,orthant2imSign,orthant2imMag,signQuant);
		const orthant3=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant3RealSign,orthant3RealMag,orthant3imSign,orthant3imMag,signQuant);
			const orthant4=fmpComplexMultiply(realOrthantSign,1,imOrthantSign,1,orthant4RealSign,orthant4RealMag,orthant4imSign,orthant4imMag,signQuant);


escapeCount2.push(fmpTricornSC(realSignIII,realMag,imSign,imMag,exponent,maxIterations,signQuant));
escapeCount3.push(fmpTricornSC(realSignIII,realMag,imSignIII,imMag,exponent,maxIterations,signQuant));
escapeCount4.push(fmpTricornSC(orthant4[0],realMag,imSignIII,imMag,exponent,maxIterations,signQuant));
}

}


	if (whichFractal==10){
//ie if whichFractal is split-complex Mandelbrot
escapeCount.push(splitMandelbrot(realMag,imMag,exponent,maxIterations));
//console.log(escapeCount);
	if (oneOrthantMode != 1){


			var orthant2RealSign=0;
			var orthant2RealMag=0;
			var orthant2imSign=2;
			var orthant2imMag=1;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=0;
			var orthant4imSign=8;
			var orthant4imMag=1;
		
	if ((((realOrthantSign == 0 && imOrthantSign == 0)||(realOrthantSign == 8 && imOrthantSign == 6))||(realOrthantSign == 8 && imOrthantSign == 8)||(realOrthantSign == 10 && imOrthantSign == 8)) || (((realOrthantSign == 8 && imOrthantSign == 10)||(realOrthantSign == 8 && imOrthantSign == 6))||(realOrthantSign == 10 && imOrthantSign == 10)||(realOrthantSign == 0 && imOrthantSign == 10))){
			var orthant2RealSign=6;
			var orthant2RealMag=1;
			var orthant2imSign=0;
			var orthant2imMag=0;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=1;
			var orthant4imSign=0;
			var orthant4imMag=0;
	}



escapeCount2.push(splitMandelbrot((-1*realMag),imMag,exponent,maxIterations));
escapeCount3.push(splitMandelbrot((-1*realMag),(-1*imMag),exponent,maxIterations));
escapeCount4.push(splitMandelbrot(realMag,(-1*imMag),exponent,maxIterations)); 
}

}

	if (whichFractal==11){
//ie if whichFractal is split-complex Tricorn
escapeCount.push(splitTricorn(realMag,imMag,exponent,maxIterations));
//console.log(escapeCount);
	if (oneOrthantMode != 1){


			var orthant2RealSign=0;
			var orthant2RealMag=0;
			var orthant2imSign=2;
			var orthant2imMag=1;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=0;
			var orthant4imSign=8;
			var orthant4imMag=1;
		
	if ((((realOrthantSign == 0 && imOrthantSign == 0)||(realOrthantSign == 8 && imOrthantSign == 6))||(realOrthantSign == 8 && imOrthantSign == 8)||(realOrthantSign == 10 && imOrthantSign == 8)) || (((realOrthantSign == 8 && imOrthantSign == 10)||(realOrthantSign == 8 && imOrthantSign == 6))||(realOrthantSign == 10 && imOrthantSign == 10)||(realOrthantSign == 0 && imOrthantSign == 10))){
			var orthant2RealSign=6;
			var orthant2RealMag=1;
			var orthant2imSign=0;
			var orthant2imMag=0;
			
			var orthant3RealSign=6;
			var orthant3RealMag=1;
			var orthant3imSign=0;
			var orthant3imMag=0;
			
			var orthant4RealSign=0;
			var orthant4RealMag=1;
			var orthant4imSign=0;
			var orthant4imMag=0;
	}



/*
	const orthant2=cHexMultiply(realOrthantSign,1,imOrthantSign,1,orthant2RealSign,orthant2RealMag,orthant2imSign,orthant2imMag);
		const orthant3=cHexMultiply(realOrthantSign,1,imOrthantSign,1,orthant3RealSign,orthant3RealMag,orthant3imSign,orthant3imMag);
			const orthant4=cHexMultiply(realOrthantSign,1,imOrthantSign,1,orthant4RealSign,orthant4RealMag,orthant4imSign,orthant4imMag);
*/

escapeCount2.push(splitTricorn((-1*realMag),imMag,exponent,maxIterations));
escapeCount3.push(splitTricorn((-1*realMag),(-1*imMag),exponent,maxIterations));
escapeCount4.push(splitTricorn(realMag,(-1*imMag),exponent,maxIterations)); 
}

}


//end Fractal computation/push escape values to array HERE!!!  	
//console.log(escapeCount.toString());

}
}


//console.log(escapeCount.toString());


}


function fourQuadrantRender(){
console.log("4Q Render Called");
            // Display result


const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = "high";
canvas.height = canvas.width;
ctx.transform(1, 0, 0, -1, 0, canvas.height)

download_img = function(el) {
  // get image URI from canvas object
  var imageURI = canvas.toDataURL("image/realOrthantSign imOrthantSign");
  el.href = imageURI;
};



//BEGIN QUADRANT ONE


ctx.fillStyle = "black";
const xArray2=[];
const yArray2=[];
for (let i = 0; i < escapeCount.length-1; i++) {

	if (escapeCount[i]==maxIterations){
		let x=(2*outputBoxSize)+(-1*(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1));
		let y=outputBoxSize-(i%outputBoxSize);
		xArray2.push(x);
		yArray2.push(y);
}

}
//console.log(yArray2.toString());

const imgData = ctx.createImageData(2*outputBoxSize, 2*outputBoxSize);


	for (let i = 0; i < xArray2.length-1; i++){

		imgData.data[0+((xArray2[i]*4)+((yArray2[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray2[i]*4)+((yArray2[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray2[i]*4)+((yArray2[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray2[i]*4)+((yArray2[i])*8*outputBoxSize))] = 255;


}

if (colorMode==0){

ctx.fillStyle = "red";
const xArray3=[];
const yArray3=[];
for (let i = 0; i < escapeCount.length-1; i++) {

	if (escapeCount[i] != maxIterations && escapeCount[i]%8==7){
		let x=(2*outputBoxSize)+(-1*(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1));
		let y=outputBoxSize-(i%outputBoxSize);
		xArray3.push(x);
		yArray3.push(y);
}

}


	for (let i = 0; i < xArray3.length-1; i++){

		imgData.data[0+((xArray3[i]*4)+((yArray3[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray3[i]*4)+((yArray3[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray3[i]*4)+((yArray3[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray3[i]*4)+((yArray3[i])*8*outputBoxSize))] = 255;


}





ctx.fillStyle = "green";
const xArray4=[];
const yArray4=[];
for (let i = 0; i < escapeCount.length-1; i++) {

	if (escapeCount[i] != maxIterations && escapeCount[i]%8==6){
		let x=(2*outputBoxSize)+(-1*(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1));
		let y=outputBoxSize-(i%outputBoxSize);
		xArray4.push(x);
		yArray4.push(y);
}

}

	for (let i = 0; i < xArray4.length-1; i++){

		imgData.data[0+((xArray4[i]*4)+((yArray4[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray4[i]*4)+((yArray4[i])*8*outputBoxSize))] = 128;
		imgData.data[2+((xArray4[i]*4)+((yArray4[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray4[i]*4)+((yArray4[i])*8*outputBoxSize))] = 255;


}

ctx.fillStyle = "purple";
const xArray5=[];
const yArray5=[];
for (let i = 0; i < escapeCount.length-1; i++) {

	if (escapeCount[i] != maxIterations && escapeCount[i]%8==5){
		let x=(2*outputBoxSize)+(-1*(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1));
		let y=outputBoxSize-(i%outputBoxSize);
		xArray5.push(x);
		yArray5.push(y);
}
}

	for (let i = 0; i < xArray5.length-1; i++){

		imgData.data[0+((xArray5[i]*4)+((yArray5[i])*8*outputBoxSize))] = 128;
		imgData.data[1+((xArray5[i]*4)+((yArray5[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray5[i]*4)+((yArray5[i])*8*outputBoxSize))] = 128;
		imgData.data[3+((xArray5[i]*4)+((yArray5[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "yellow";
const xArray6=[];
const yArray6=[];
for (let i = 0; i < escapeCount.length-1; i++) {

	if (escapeCount[i] != maxIterations && escapeCount[i]%8==4){
		let x=(2*outputBoxSize)+(-1*(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1));
		let y=outputBoxSize-(i%outputBoxSize);
		xArray6.push(x);
		yArray6.push(y);
}

}

	for (let i = 0; i < xArray6.length-1; i++){

		imgData.data[0+((xArray6[i]*4)+((yArray6[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray6[i]*4)+((yArray6[i])*8*outputBoxSize))] = 255;
		imgData.data[2+((xArray6[i]*4)+((yArray6[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray6[i]*4)+((yArray6[i])*8*outputBoxSize))] = 255;


}




ctx.fillStyle = "blue";
const xArray7=[];
const yArray7=[];
for (let i = 0; i < escapeCount.length-1; i++) {

	if (escapeCount[i] != maxIterations && escapeCount[i]%8==3){
		let x=(2*outputBoxSize)+(-1*(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1));
		let y=outputBoxSize-(i%outputBoxSize);
		xArray7.push(x);
		yArray7.push(y);
}

}

	for (let i = 0; i < xArray7.length-1; i++){

		imgData.data[0+((xArray7[i]*4)+((yArray7[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray7[i]*4)+((yArray7[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray7[i]*4)+((yArray7[i])*8*outputBoxSize))] = 255;
		imgData.data[3+((xArray7[i]*4)+((yArray7[i])*8*outputBoxSize))] = 255;


}

ctx.fillStyle = "orange";
const xArray8=[];
const yArray8=[];
for (let i = 0; i < escapeCount.length-1; i++) {

	if (escapeCount[i] != maxIterations && escapeCount[i]%8==2){
		let x=(2*outputBoxSize)+(-1*(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1));
		let y=outputBoxSize-(i%outputBoxSize);
		xArray8.push(x);
		yArray8.push(y);
}

}

	for (let i = 0; i < xArray8.length-1; i++){

		imgData.data[0+((xArray8[i]*4)+((yArray8[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray8[i]*4)+((yArray8[i])*8*outputBoxSize))] = 165;
		imgData.data[2+((xArray8[i]*4)+((yArray8[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray8[i]*4)+((yArray8[i])*8*outputBoxSize))] = 255;


}

ctx.fillStyle = "cyan";
const xArray9=[];
const yArray9=[];
for (let i = 0; i < escapeCount.length-1; i++) {

	if (escapeCount[i] != maxIterations && escapeCount[i]%8==1){
		let x=(2*outputBoxSize)+(-1*(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1));
		let y=outputBoxSize-(i%outputBoxSize);
		xArray9.push(x);
		yArray9.push(y);
}

}

	for (let i = 0; i < xArray9.length-1; i++){

		imgData.data[0+((xArray9[i]*4)+((yArray9[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray9[i]*4)+((yArray9[i])*8*outputBoxSize))] = 255;
		imgData.data[2+((xArray9[i]*4)+((yArray9[i])*8*outputBoxSize))] = 255;
		imgData.data[3+((xArray9[i]*4)+((yArray9[i])*8*outputBoxSize))] = 255;


}

ctx.fillStyle = "white";
const xArray10=[];
const yArray10=[];
for (let i = 0; i < escapeCount.length-1; i++) {

	if ((escapeCount[i] != maxIterations && escapeCount[i]%8==0) && escapeCount[i] != 0){
		let x=(2*outputBoxSize)+(-1*(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1));
		let y=outputBoxSize-(i%outputBoxSize);
		xArray10.push(x);
		yArray10.push(y);
}

}

	for (let i = 0; i < xArray10.length-1; i++){

		imgData.data[0+((xArray10[i]*4)+((yArray10[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray10[i]*4)+((yArray10[i])*8*outputBoxSize))] = 255;
		imgData.data[2+((xArray10[i]*4)+((yArray10[i])*8*outputBoxSize))] = 255;
		imgData.data[3+((xArray10[i]*4)+((yArray10[i])*8*outputBoxSize))] = 255;


}
}
ctx.putImageData(imgData, 0, -1);




//END QUADRANT ONE

	if (oneOrthantMode != 1){

//BEGIN QUADRANT TWO

ctx.fillStyle = "black";
const xArray22=[];
const yArray22=[];
for (let i = 0; i < escapeCount2.length-1; i++) {

	if (escapeCount2[i]==maxIterations){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize-(i%outputBoxSize);
		xArray22.push(x);
		yArray22.push(y);
}

}


	for (let i = 0; i < xArray22.length-1; i++){

		imgData.data[0+((xArray22[i]*4)+((yArray22[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray22[i]*4)+((yArray22[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray22[i]*4)+((yArray22[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray22[i]*4)+((yArray22[i])*8*outputBoxSize))] = 255;


}


	if (colorMode==0){
ctx.fillStyle = "red";
const xArray32=[];
const yArray32=[];
for (let i = 0; i < escapeCount2.length-1; i++) {

	if (escapeCount2[i] != maxIterations && escapeCount2[i]%8==7){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize-(i%outputBoxSize);
		xArray32.push(x);
		yArray32.push(y);
}

}

	for (let i = 0; i < xArray32.length-1; i++){

		imgData.data[0+((xArray32[i]*4)+((yArray32[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray32[i]*4)+((yArray32[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray32[i]*4)+((yArray32[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray32[i]*4)+((yArray32[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "green";
const xArray42=[];
const yArray42=[];
for (let i = 0; i < escapeCount2.length-1; i++) {

	if (escapeCount2[i] != maxIterations && escapeCount2[i]%8==6){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize-(i%outputBoxSize);
		xArray42.push(x);
		yArray42.push(y);
}

}


	for (let i = 0; i < xArray42.length-1; i++){

		imgData.data[0+((xArray42[i]*4)+((yArray42[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray42[i]*4)+((yArray42[i])*8*outputBoxSize))] = 128;
		imgData.data[2+((xArray42[i]*4)+((yArray42[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray42[i]*4)+((yArray42[i])*8*outputBoxSize))] = 255;


}

ctx.fillStyle = "purple";
const xArray52=[];
const yArray52=[];
for (let i = 0; i < escapeCount2.length-1; i++) {

	if (escapeCount2[i] != maxIterations && escapeCount2[i]%8==5){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize-(i%outputBoxSize);
		xArray52.push(x);
		yArray52.push(y);
}

}


	for (let i = 0; i < xArray52.length-1; i++){

		imgData.data[0+((xArray52[i]*4)+((yArray52[i])*8*outputBoxSize))] = 126;
		imgData.data[1+((xArray52[i]*4)+((yArray52[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray52[i]*4)+((yArray52[i])*8*outputBoxSize))] = 126;
		imgData.data[3+((xArray52[i]*4)+((yArray52[i])*8*outputBoxSize))] = 255;


}

ctx.fillStyle = "yellow";
const xArray62=[];
const yArray62=[];
for (let i = 0; i < escapeCount2.length-1; i++) {

	if (escapeCount2[i] != maxIterations && escapeCount2[i]%8==4){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize-(i%outputBoxSize);
		xArray62.push(x);
		yArray62.push(y);
}

}

	for (let i = 0; i < xArray62.length-1; i++){

		imgData.data[0+((xArray62[i]*4)+((yArray62[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray62[i]*4)+((yArray62[i])*8*outputBoxSize))] = 255;
		imgData.data[2+((xArray62[i]*4)+((yArray62[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray62[i]*4)+((yArray62[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "blue";
const xArray72=[];
const yArray72=[];
for (let i = 0; i < escapeCount2.length-1; i++) {

	if (escapeCount2[i] != maxIterations && escapeCount2[i]%8==3){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize-(i%outputBoxSize);
		xArray72.push(x);
		yArray72.push(y);
}

}


	for (let i = 0; i < xArray72.length-1; i++){

		imgData.data[0+((xArray72[i]*4)+((yArray72[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray72[i]*4)+((yArray72[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray72[i]*4)+((yArray72[i])*8*outputBoxSize))] = 255;
		imgData.data[3+((xArray72[i]*4)+((yArray72[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "orange";
const xArray82=[];
const yArray82=[];
for (let i = 0; i < escapeCount2.length-1; i++) {

	if (escapeCount2[i] != maxIterations && escapeCount2[i]%8==2){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize-(i%outputBoxSize);
		xArray82.push(x);
		yArray82.push(y);
}

}


	for (let i = 0; i < xArray82.length-1; i++){

		imgData.data[0+((xArray82[i]*4)+((yArray82[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray82[i]*4)+((yArray82[i])*8*outputBoxSize))] = 165;
		imgData.data[2+((xArray82[i]*4)+((yArray82[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray82[i]*4)+((yArray82[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "cyan";
const xArray92=[];
const yArray92=[];
for (let i = 0; i < escapeCount2.length-1; i++) {

	if (escapeCount2[i] != maxIterations && escapeCount2[i]%8==1){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize-(i%outputBoxSize);
		xArray92.push(x);
		yArray92.push(y);
}

}


	for (let i = 0; i < xArray92.length-1; i++){

		imgData.data[0+((xArray92[i]*4)+((yArray92[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray92[i]*4)+((yArray92[i])*8*outputBoxSize))] = 255;
		imgData.data[2+((xArray92[i]*4)+((yArray92[i])*8*outputBoxSize))] = 255;
		imgData.data[3+((xArray92[i]*4)+((yArray92[i])*8*outputBoxSize))] = 255;


}

ctx.fillStyle = "white";
const xArray102=[];
const yArray102=[];
for (let i = 0; i < escapeCount2.length-1; i++) {

	if ((escapeCount2[i] != maxIterations && escapeCount2[i]%8==0) && escapeCount2[i] != 0){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize-(i%outputBoxSize);
		xArray102.push(x);
		yArray102.push(y);
}

}


	for (let i = 0; i < xArray102.length-1; i++){

		imgData.data[0+((xArray102[i]*4)+((yArray102[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray102[i]*4)+((yArray102[i])*8*outputBoxSize))] = 255;
		imgData.data[2+((xArray102[i]*4)+((yArray102[i])*8*outputBoxSize))] = 255;
		imgData.data[3+((xArray102[i]*4)+((yArray102[i])*8*outputBoxSize))] = 255;


}
}
//END QUADRANT TWO


//BEGIN QUADRANT THREE

ctx.fillStyle = "black";
const xArray23=[];
const yArray23=[];
for (let i = 0; i < escapeCount3.length-1; i++) {

	if (escapeCount3[i]==maxIterations){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize+(i%outputBoxSize);
		xArray23.push(x);
		yArray23.push(y);
}

}

	for (let i = 0; i < xArray23.length-1; i++){

		imgData.data[0+((xArray23[i]*4)+((yArray23[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray23[i]*4)+((yArray23[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray23[i]*4)+((yArray23[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray23[i]*4)+((yArray23[i])*8*outputBoxSize))] = 255;


}

	if (colorMode==0){

ctx.fillStyle = "red";
const xArray33=[];
const yArray33=[];
for (let i = 0; i < escapeCount3.length-1; i++) {

	if (escapeCount3[i] != maxIterations && escapeCount3[i]%8==7){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize+((i%outputBoxSize));
		xArray33.push(x);
		yArray33.push(y);
}

}


	for (let i = 0; i < xArray33.length-1; i++){

		imgData.data[0+((xArray33[i]*4)+((yArray33[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray33[i]*4)+((yArray33[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray33[i]*4)+((yArray33[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray33[i]*4)+((yArray33[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "green";
const xArray43=[];
const yArray43=[];
for (let i = 0; i < escapeCount3.length-1; i++) {

	if (escapeCount3[i] != maxIterations && escapeCount3[i]%8==6){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize+((i%outputBoxSize));
		xArray43.push(x);
		yArray43.push(y);
}

}

	for (let i = 0; i < xArray43.length-1; i++){

		imgData.data[0+((xArray43[i]*4)+((yArray43[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray43[i]*4)+((yArray43[i])*8*outputBoxSize))] = 128;
		imgData.data[2+((xArray43[i]*4)+((yArray43[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray43[i]*4)+((yArray43[i])*8*outputBoxSize))] = 255;


}

ctx.fillStyle = "purple";
const xArray53=[];
const yArray53=[];
for (let i = 0; i < escapeCount3.length-1; i++) {

	if (escapeCount3[i] != maxIterations && escapeCount3[i]%8==5){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize+((i%outputBoxSize));
		xArray53.push(x);
		yArray53.push(y);
}

}


	for (let i = 0; i < xArray53.length-1; i++){

		imgData.data[0+((xArray53[i]*4)+((yArray53[i])*8*outputBoxSize))] = 128;
		imgData.data[1+((xArray53[i]*4)+((yArray53[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray53[i]*4)+((yArray53[i])*8*outputBoxSize))] = 128;
		imgData.data[3+((xArray53[i]*4)+((yArray53[i])*8*outputBoxSize))] = 255;


}

ctx.fillStyle = "yellow";
const xArray63=[];
const yArray63=[];
for (let i = 0; i < escapeCount3.length-1; i++) {

	if (escapeCount3[i] != maxIterations && escapeCount3[i]%8==4){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize+((i%outputBoxSize));
		xArray63.push(x);
		yArray63.push(y);
}

}

	for (let i = 0; i < xArray63.length-1; i++){

		imgData.data[0+((xArray63[i]*4)+((yArray63[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray63[i]*4)+((yArray63[i])*8*outputBoxSize))] = 255;
		imgData.data[2+((xArray63[i]*4)+((yArray63[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray63[i]*4)+((yArray63[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "blue";
const xArray73=[];
const yArray73=[];
for (let i = 0; i < escapeCount3.length-1; i++) {

	if (escapeCount3[i] != maxIterations && escapeCount3[i]%8==3){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize+((i%outputBoxSize));
		xArray73.push(x);
		yArray73.push(y);
}

}

	for (let i = 0; i < xArray73.length-1; i++){

		imgData.data[0+((xArray73[i]*4)+((yArray73[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray73[i]*4)+((yArray73[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray73[i]*4)+((yArray73[i])*8*outputBoxSize))] = 255;
		imgData.data[3+((xArray73[i]*4)+((yArray73[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "orange";
const xArray83=[];
const yArray83=[];
for (let i = 0; i < escapeCount3.length-1; i++) {

	if (escapeCount3[i] != maxIterations && escapeCount3[i]%8==2){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize+((i%outputBoxSize));
		xArray83.push(x);
		yArray83.push(y);
}

}

	for (let i = 0; i < xArray83.length-1; i++){

		imgData.data[0+((xArray83[i]*4)+((yArray83[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray83[i]*4)+((yArray83[i])*8*outputBoxSize))] = 165;
		imgData.data[2+((xArray83[i]*4)+((yArray83[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray83[i]*4)+((yArray83[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "cyan";
const xArray93=[];
const yArray93=[];
for (let i = 0; i < escapeCount3.length-1; i++) {

	if (escapeCount3[i] != maxIterations && escapeCount3[i]%8==1){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize+((i%outputBoxSize));
		xArray93.push(x);
		yArray93.push(y);
}

}


	for (let i = 0; i < xArray93.length-1; i++){

		imgData.data[0+((xArray93[i]*4)+((yArray93[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray93[i]*4)+((yArray93[i])*8*outputBoxSize))] = 255;
		imgData.data[2+((xArray93[i]*4)+((yArray93[i])*8*outputBoxSize))] = 255;
		imgData.data[3+((xArray93[i]*4)+((yArray93[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "white";
const xArray103=[];
const yArray103=[];
for (let i = 0; i < escapeCount3.length-1; i++) {

	if ((escapeCount3[i] != maxIterations && escapeCount3[i]%8==0) && escapeCount3[i] != 0){
		let x=(Math.floor(i/outputBoxSize+1))%(outputBoxSize+1);
		let y=outputBoxSize+((i%outputBoxSize));
		xArray103.push(x);
		yArray103.push(y);
}

}


	for (let i = 0; i < xArray103.length-1; i++){

		imgData.data[0+((xArray103[i]*4)+((yArray103[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray103[i]*4)+((yArray103[i])*8*outputBoxSize))] = 255;
		imgData.data[2+((xArray103[i]*4)+((yArray103[i])*8*outputBoxSize))] = 255;
		imgData.data[3+((xArray103[i]*4)+((yArray103[i])*8*outputBoxSize))] = 255;


}

}

//END QUADRANT THREE

//BEGIN QUADRANT FOUR

ctx.fillStyle = "black";
const xArray24=[];
const yArray24=[];
for (let i = 0; i < escapeCount4.length-1; i++) {

	if (escapeCount4[i]==maxIterations){
		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize+((i%outputBoxSize));
		xArray24.push(x);
		yArray24.push(y);
}

}


	for (let i = 0; i < xArray24.length-1; i++){

		imgData.data[0+((xArray24[i]*4)+((yArray24[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray24[i]*4)+((yArray24[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray24[i]*4)+((yArray24[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray24[i]*4)+((yArray24[i])*8*outputBoxSize))] = 255;


}


	if (colorMode==0){
ctx.fillStyle = "red";
const xArray34=[];
const yArray34=[];
for (let i = 0; i < escapeCount4.length-1; i++) {

	if (escapeCount4[i] != maxIterations && escapeCount4[i]%8==7){
		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize+((i%outputBoxSize));
		xArray34.push(x);
		yArray34.push(y);
}

}

	for (let i = 0; i < xArray34.length-1; i++){

		imgData.data[0+((xArray34[i]*4)+((yArray34[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray34[i]*4)+((yArray34[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray34[i]*4)+((yArray34[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray34[i]*4)+((yArray34[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "green";
const xArray44=[];
const yArray44=[];
for (let i = 0; i < escapeCount4.length-1; i++) {

	if (escapeCount4[i] != maxIterations && escapeCount4[i]%8==6){
		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize+((i%outputBoxSize));
		xArray44.push(x);
		yArray44.push(y);
}

}

	for (let i = 0; i < xArray44.length-1; i++){

		imgData.data[0+((xArray44[i]*4)+((yArray44[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray44[i]*4)+((yArray44[i])*8*outputBoxSize))] = 128;
		imgData.data[2+((xArray44[i]*4)+((yArray44[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray44[i]*4)+((yArray44[i])*8*outputBoxSize))] = 255;


}

ctx.fillStyle = "purple";
const xArray54=[];
const yArray54=[];
for (let i = 0; i < escapeCount4.length-1; i++) {

	if (escapeCount4[i] != maxIterations && escapeCount4[i]%8==5){
		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize+((i%outputBoxSize));
		xArray54.push(x);
		yArray54.push(y);
}

}


	for (let i = 0; i < xArray54.length-1; i++){

		imgData.data[0+((xArray54[i]*4)+((yArray54[i])*8*outputBoxSize))] = 128;
		imgData.data[1+((xArray54[i]*4)+((yArray54[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray54[i]*4)+((yArray54[i])*8*outputBoxSize))] = 128;
		imgData.data[3+((xArray54[i]*4)+((yArray54[i])*8*outputBoxSize))] = 255;


}

ctx.fillStyle = "yellow";
const xArray64=[];
const yArray64=[];
for (let i = 0; i < escapeCount4.length-1; i++) {

	if (escapeCount4[i] != maxIterations && escapeCount4[i]%8==4){
		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize+((i%outputBoxSize));
		xArray64.push(x);
		yArray64.push(y);
}

}

	for (let i = 0; i < xArray64.length-1; i++){

		imgData.data[0+((xArray64[i]*4)+((yArray64[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray64[i]*4)+((yArray64[i])*8*outputBoxSize))] = 255;
		imgData.data[2+((xArray64[i]*4)+((yArray64[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray64[i]*4)+((yArray64[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "blue";
const xArray74=[];
const yArray74=[];
for (let i = 0; i < escapeCount4.length-1; i++) {

	if (escapeCount4[i] != maxIterations && escapeCount4[i]%8==3){
		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize+((i%outputBoxSize));
		xArray74.push(x);
		yArray74.push(y);
}

}

	for (let i = 0; i < xArray74.length-1; i++){

		imgData.data[0+((xArray74[i]*4)+((yArray74[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray74[i]*4)+((yArray74[i])*8*outputBoxSize))] = 0;
		imgData.data[2+((xArray74[i]*4)+((yArray74[i])*8*outputBoxSize))] = 255;
		imgData.data[3+((xArray74[i]*4)+((yArray74[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "orange";
const xArray84=[];
const yArray84=[];
for (let i = 0; i < escapeCount4.length-1; i++) {

	if (escapeCount4[i] != maxIterations && escapeCount4[i]%8==2){
		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize+((i%outputBoxSize));
		xArray84.push(x);
		yArray84.push(y);
}

}


	for (let i = 0; i < xArray84.length-1; i++){

		imgData.data[0+((xArray84[i]*4)+((yArray84[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray84[i]*4)+((yArray84[i])*8*outputBoxSize))] = 165;
		imgData.data[2+((xArray84[i]*4)+((yArray84[i])*8*outputBoxSize))] = 0;
		imgData.data[3+((xArray84[i]*4)+((yArray84[i])*8*outputBoxSize))] = 255;


}


ctx.fillStyle = "cyan";
const xArray94=[];
const yArray94=[];
for (let i = 0; i < escapeCount4.length-1; i++) {

	if (escapeCount4[i] != maxIterations && escapeCount4[i]%8==1){
		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize+((i%outputBoxSize));
		xArray94.push(x);
		yArray94.push(y);
}

}


	for (let i = 0; i < xArray94.length-1; i++){

		imgData.data[0+((xArray94[i]*4)+((yArray94[i])*8*outputBoxSize))] = 0;
		imgData.data[1+((xArray94[i]*4)+((yArray94[i])*8*outputBoxSize))] = 255;
		imgData.data[2+((xArray94[i]*4)+((yArray94[i])*8*outputBoxSize))] = 255;
		imgData.data[3+((xArray94[i]*4)+((yArray94[i])*8*outputBoxSize))] = 255;


}

ctx.fillStyle = "white";
const xArray104=[];
const yArray104=[];
for (let i = 0; i < escapeCount4.length-1; i++) {

	if ((escapeCount4[i] != maxIterations && escapeCount4[i]%8==0) && escapeCount4[i] != 0){
		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize+((i%outputBoxSize));
		xArray104.push(x);
		yArray104.push(y);
}

}


	for (let i = 0; i < xArray104.length-1; i++){

		imgData.data[0+((xArray104[i]*4)+((yArray104[i])*8*outputBoxSize))] = 255;
		imgData.data[1+((xArray104[i]*4)+((yArray104[i])*8*outputBoxSize))] = 255;
		imgData.data[2+((xArray104[i]*4)+((yArray104[i])*8*outputBoxSize))] = 255;
		imgData.data[3+((xArray104[i]*4)+((yArray104[i])*8*outputBoxSize))] = 255;


}
}
}
//END QUADRANT FOUR


	if (colorMode==1){

	const glowXArray=[];
	const glowYArray=[];
		const glowXArray2=[];
	const glowYArray2=[];
		const glowXArray3=[];
	const glowYArray3=[];
		const glowXArray4=[];
	const glowYArray4=[];
	for (let i = 0; i < escapeCount.length-1; i++){
		let escapeIncrement=255/maxIterations;

		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize-((i%outputBoxSize));
		glowXArray.push(x);
		glowYArray.push(y);


		imgData.data[0+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = escapeCount[i]*escapeIncrement;
		imgData.data[1+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = escapeCount[i]*escapeIncrement;
		imgData.data[2+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = escapeCount[i]*escapeIncrement;
		imgData.data[3+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = escapeCount[i]*escapeIncrement;

		let x2=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y2=outputBoxSize-((i%outputBoxSize));
		glowXArray2.push(x2);
		glowYArray2.push(y2-1);


		imgData.data[0+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = escapeCount2[i]*escapeIncrement;
		imgData.data[1+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = escapeCount2[i]*escapeIncrement;
		imgData.data[2+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = escapeCount2[i]*escapeIncrement;
		imgData.data[3+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = escapeCount2[i]*escapeIncrement;

		let x3=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y3=outputBoxSize+((i%outputBoxSize));
		glowXArray3.push(x3);
		glowYArray3.push(y3-1);


		imgData.data[0+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = escapeCount3[i]*escapeIncrement;
		imgData.data[1+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = escapeCount3[i]*escapeIncrement;
		imgData.data[2+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = escapeCount3[i]*escapeIncrement;
		imgData.data[3+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = escapeCount3[i]*escapeIncrement;


		let x4=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y4=outputBoxSize+((i%outputBoxSize));
		glowXArray4.push(x4);
		glowYArray4.push(y4);


		imgData.data[0+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = escapeCount4[i]*escapeIncrement;
		imgData.data[1+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = escapeCount4[i]*escapeIncrement;
		imgData.data[2+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = escapeCount4[i]*escapeIncrement;
		imgData.data[3+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = escapeCount4[i]*escapeIncrement;



}
}


	if (colorMode==2){

	const glowXArray=[];
	const glowYArray=[];
		const glowXArray2=[];
	const glowYArray2=[];
		const glowXArray3=[];
	const glowYArray3=[];
		const glowXArray4=[];
	const glowYArray4=[];
	for (let i = 0; i < escapeCount.length-1; i++){
		let escapeIncrement=255/maxIterations;

		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize-((i%outputBoxSize));
		glowXArray.push(x);
		glowYArray.push(y);
		let x2=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y2=outputBoxSize-((i%outputBoxSize));
		glowXArray2.push(x2);
		glowYArray2.push(y2-1);
				let x3=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y3=outputBoxSize+((i%outputBoxSize));
		glowXArray3.push(x3);
		glowYArray3.push(y3-1);
		let x4=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y4=outputBoxSize+((i%outputBoxSize));
		glowXArray4.push(x4);
		glowYArray4.push(y4);
		
		imgData.data[0+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = (((escapeCount[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgData.data[1+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = (((escapeCount[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgData.data[2+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = (((escapeCount[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgData.data[3+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 255;

		imgData.data[0+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = (((escapeCount2[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgData.data[1+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = (((escapeCount2[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgData.data[2+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = (((escapeCount2[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgData.data[3+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 255;

		imgData.data[0+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = (((escapeCount3[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgData.data[1+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = (((escapeCount3[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgData.data[2+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = (((escapeCount3[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgData.data[3+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 255;

		imgData.data[0+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = (((escapeCount4[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgData.data[1+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = (((escapeCount4[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgData.data[2+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = (((escapeCount4[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgData.data[3+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 255;



}
}


//mode 3 emulates viridis with RGB ranges 253-68 (midpoint ~31); 231, 1; 37-84 (midpoint ~140)


	if (colorMode==3){

	let iterationMidpoint=Math.round(maxIterations/2);

//highest escapeCount -> 253,231,37
//midpoint escapeCount -> 31, 145, 140
//lowest escapeCount -> 68,1,84
	const glowXArray=[];
	const glowYArray=[];
		const glowXArray2=[];
	const glowYArray2=[];
		const glowXArray3=[];
	const glowYArray3=[];
		const glowXArray4=[];
	const glowYArray4=[];
	for (let i = 0; i < escapeCount.length-1; i++){
		let escapeIncrement=255/maxIterations;

		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize-((i%outputBoxSize));
		glowXArray.push(x);
		glowYArray.push(y);
		let x2=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y2=outputBoxSize-((i%outputBoxSize));
		glowXArray2.push(x2);
		glowYArray2.push(y2-1);
				let x3=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y3=outputBoxSize+((i%outputBoxSize));
		glowXArray3.push(x3);
		glowYArray3.push(y3-1);
		let x4=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y4=outputBoxSize+((i%outputBoxSize));
		glowXArray4.push(x4);
		glowYArray4.push(y4);
		
if (((escapeCount[i]+mode3ModuloOffset)%maxIterations)==iterationMidpoint){ 31, 145, 140
  		imgData.data[0+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 31;
		imgData.data[1+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 145;
		imgData.data[2+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 140;
		imgData.data[3+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 255;}

if (((escapeCount2[i]+mode3ModuloOffset)%maxIterations)==iterationMidpoint){
		imgData.data[0+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 31;
		imgData.data[1+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 145;
		imgData.data[2+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 140;
		imgData.data[3+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 255;
}

if (((escapeCount3[i]+mode3ModuloOffset)%maxIterations)==iterationMidpoint){
		imgData.data[0+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 31;
		imgData.data[1+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 145;
		imgData.data[2+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 140;
		imgData.data[3+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 255;
}

if (((escapeCount4[i]+mode3ModuloOffset)%maxIterations)==iterationMidpoint){
		imgData.data[0+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 31;
		imgData.data[1+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 145;
		imgData.data[2+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 140;
		imgData.data[3+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 255;
}

 if (((escapeCount[i]+mode3ModuloOffset)%maxIterations)>iterationMidpoint){ 

//highest escapeCount -> 253,231,37
//midpoint escapeCount -> 31, 145, 140
//lowest escapeCount -> 68,1,84

		imgData.data[0+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = ((222/(iterationMidpoint-1))*(((escapeCount[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+31;
		imgData.data[1+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = ((86/(iterationMidpoint-1))*(((escapeCount[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+145;
		imgData.data[2+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = ((-103/(iterationMidpoint-1))*(((escapeCount[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+140;
		imgData.data[3+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 255;
}

 if (((escapeCount2[i]+mode3ModuloOffset)%maxIterations)>iterationMidpoint){ 
		imgData.data[0+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = ((222/(iterationMidpoint-1))*(((escapeCount2[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+31;
		imgData.data[1+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = ((86/(iterationMidpoint-1))*(((escapeCount2[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+145;
		imgData.data[2+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = ((-103/(iterationMidpoint-1))*(((escapeCount2[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+140;
		imgData.data[3+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 255;
}

 if (((escapeCount3[i]+mode3ModuloOffset)%maxIterations)>iterationMidpoint){ 
		imgData.data[0+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = ((222/(iterationMidpoint-1))*(((escapeCount3[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+31;
		imgData.data[1+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = ((86/(iterationMidpoint-1))*(((escapeCount3[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+145;
		imgData.data[2+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = ((-103/(iterationMidpoint-1))*(((escapeCount3[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+140;
		imgData.data[3+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 255;
}

 if (((escapeCount4[i]+mode3ModuloOffset)%maxIterations)>iterationMidpoint){ 
		imgData.data[0+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = ((222/(iterationMidpoint-1))*(((escapeCount4[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+31;
		imgData.data[1+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = ((86/(iterationMidpoint-1))*(((escapeCount4[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+145;
		imgData.data[2+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = ((-103/(iterationMidpoint-1))*(((escapeCount4[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+140;
		imgData.data[3+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 255;

} 


	if (((escapeCount[i]+mode3ModuloOffset)%maxIterations)<iterationMidpoint){

//highest escapeCount -> 253,231,37
//midpoint escapeCount -> 31, 145, 140
//lowest escapeCount -> 68,1,84

		imgData.data[0+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = ((37/(iterationMidpoint-1))*(((escapeCount[i]+mode3ModuloOffset)%maxIterations)))+31;
		imgData.data[1+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = ((143/(iterationMidpoint-1))*(((escapeCount[i]+mode3ModuloOffset)%maxIterations)))+1;
		imgData.data[2+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = ((56/(iterationMidpoint-1))*(((escapeCount[i]+mode3ModuloOffset)%maxIterations)))+84;
		imgData.data[3+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 255;
}

	if (((escapeCount2[i]+mode3ModuloOffset)%maxIterations)<iterationMidpoint){
		imgData.data[0+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = ((37/(iterationMidpoint-1))*(((escapeCount2[i]+mode3ModuloOffset)%maxIterations)))+31;
		imgData.data[1+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = ((143/(iterationMidpoint-1))*(((escapeCount2[i]+mode3ModuloOffset)%maxIterations)))+1;
		imgData.data[2+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = ((56/(iterationMidpoint-1))*(((escapeCount2[i]+mode3ModuloOffset)%maxIterations)))+84;
		imgData.data[3+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 255;
}

	if (((escapeCount3[i]+mode3ModuloOffset)%maxIterations)<iterationMidpoint){
		imgData.data[0+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = ((37/(iterationMidpoint-1))*(((escapeCount3[i]+mode3ModuloOffset)%maxIterations)))+31;
		imgData.data[1+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = ((143/(iterationMidpoint-1))*(((escapeCount3[i]+mode3ModuloOffset)%maxIterations)))+1;
		imgData.data[2+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = ((56/(iterationMidpoint-1))*(((escapeCount3[i]+mode3ModuloOffset)%maxIterations)))+84;
		imgData.data[3+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 255;
}

	if (((escapeCount4[i]+mode3ModuloOffset)%maxIterations)<iterationMidpoint){
		imgData.data[0+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = ((37/(iterationMidpoint-1))*(((escapeCount4[i]+mode3ModuloOffset)%maxIterations)))+31;
		imgData.data[1+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = ((143/(iterationMidpoint-1))*(((escapeCount4[i]+mode3ModuloOffset)%maxIterations)))+1;
		imgData.data[2+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = ((56/(iterationMidpoint-1))*(((escapeCount4[i]+mode3ModuloOffset)%maxIterations)))+84;
		imgData.data[3+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 255;

}

}
}

/////COLORMODE4

	if (colorMode==4){

	let iterationMidpoint=Math.round(maxIterations/2);

//mode 4 emulates plasma from matplotlib with RGB ranges 240-13 (midpoint ~204); 249, 8 (midpoint ~71); 33-135 (midpoint ~120); mode 3 also has a mode4ModuloOffset parameter.

//high 240,249,33
//midpoint - 204,71,120
//low - 13,8,135


	const glowXArray=[];
	const glowYArray=[];
		const glowXArray2=[];
	const glowYArray2=[];
		const glowXArray3=[];
	const glowYArray3=[];
		const glowXArray4=[];
	const glowYArray4=[];
	for (let i = 0; i < escapeCount.length-1; i++){
		let escapeIncrement=255/maxIterations;

		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize-((i%outputBoxSize));
		glowXArray.push(x);
		glowYArray.push(y);
		let x2=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y2=outputBoxSize-((i%outputBoxSize));
		glowXArray2.push(x2);
		glowYArray2.push(y2-1);
				let x3=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y3=outputBoxSize+((i%outputBoxSize));
		glowXArray3.push(x3);
		glowYArray3.push(y3-1);
		let x4=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y4=outputBoxSize+((i%outputBoxSize));
		glowXArray4.push(x4);
		glowYArray4.push(y4);
		
if (((escapeCount[i]+mode4ModuloOffset)%maxIterations)==iterationMidpoint){ 
		imgData.data[0+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 204;
		imgData.data[1+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 71;
		imgData.data[2+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 120;
		imgData.data[3+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 255;
}

if (((escapeCount2[i]+mode4ModuloOffset)%maxIterations)==iterationMidpoint){ 
		imgData.data[0+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 204;
		imgData.data[1+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 71;
		imgData.data[2+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 120;
		imgData.data[3+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 255;
}

if (((escapeCount3[i]+mode4ModuloOffset)%maxIterations)==iterationMidpoint){ 
		imgData.data[0+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 204;
		imgData.data[1+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 71;
		imgData.data[2+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 120;
		imgData.data[3+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 255;
}

if (((escapeCount4[i]+mode4ModuloOffset)%maxIterations)==iterationMidpoint){ 
		imgData.data[0+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 204;
		imgData.data[1+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 71;
		imgData.data[2+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 120;
		imgData.data[3+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 255;
} 

if (((escapeCount[i]+mode4ModuloOffset)%maxIterations)>iterationMidpoint){ 

//high 240,249,33
//midpoint - 204,71,120
//low - 13,8,135

	
		imgData.data[0+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = ((36/(iterationMidpoint-1))*(((escapeCount[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+204;
		imgData.data[1+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = ((178/(iterationMidpoint-1))*(((escapeCount[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+71;
		imgData.data[2+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = ((-87/(iterationMidpoint-1))*(((escapeCount[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+120;
		imgData.data[3+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 255;
}

if (((escapeCount2[i]+mode4ModuloOffset)%maxIterations)>iterationMidpoint){ 
		imgData.data[0+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = ((36/(iterationMidpoint-1))*(((escapeCount2[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+204;
		imgData.data[1+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = ((178/(iterationMidpoint-1))*(((escapeCount2[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+71;
		imgData.data[2+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = ((-87/(iterationMidpoint-1))*(((escapeCount2[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+120;
		imgData.data[3+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 255;
}

if (((escapeCount3[i]+mode4ModuloOffset)%maxIterations)>iterationMidpoint){ 
		imgData.data[0+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = ((36/(iterationMidpoint-1))*(((escapeCount3[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+204;
		imgData.data[1+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = ((178/(iterationMidpoint-1))*(((escapeCount3[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+71;
		imgData.data[2+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = ((-87/(iterationMidpoint-1))*(((escapeCount3[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+120;
		imgData.data[3+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 255;
}

if (((escapeCount4[i]+mode4ModuloOffset)%maxIterations)>iterationMidpoint){ 
		imgData.data[0+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = ((36/(iterationMidpoint-1))*(((escapeCount4[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+204;
		imgData.data[1+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = ((178/(iterationMidpoint-1))*(((escapeCount4[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+71;
		imgData.data[2+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = ((-87/(iterationMidpoint-1))*(((escapeCount4[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+120;
		imgData.data[3+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 255;

} 


	if (((escapeCount[i]+mode4ModuloOffset)%maxIterations)<iterationMidpoint){

//high 240,249,33
//midpoint - 204,71,120
//low - 13,8,135

		imgData.data[0+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = ((191/(iterationMidpoint-1))*(((escapeCount[i]+mode4ModuloOffset)%maxIterations)))+13;
		imgData.data[1+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = ((63/(iterationMidpoint-1))*(((escapeCount[i]+mode4ModuloOffset)%maxIterations)))+8;
		imgData.data[2+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = ((-15/(iterationMidpoint-1))*(((escapeCount[i]+mode4ModuloOffset)%maxIterations)))+135;
		imgData.data[3+((glowXArray[i]*4)+((glowYArray[i])*8*outputBoxSize))] = 255;
}

	if (((escapeCount2[i]+mode4ModuloOffset)%maxIterations)<iterationMidpoint){
		imgData.data[0+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = ((191/(iterationMidpoint-1))*(((escapeCount2[i]+mode4ModuloOffset)%maxIterations)))+13;
		imgData.data[1+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = ((63/(iterationMidpoint-1))*(((escapeCount2[i]+mode4ModuloOffset)%maxIterations)))+8;
		imgData.data[2+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = ((-15/(iterationMidpoint-1))*(((escapeCount2[i]+mode4ModuloOffset)%maxIterations)))+135;
		imgData.data[3+((glowXArray2[i]*4)+((glowYArray2[i])*8*outputBoxSize))] = 255;
}

	if (((escapeCount3[i]+mode4ModuloOffset)%maxIterations)<iterationMidpoint){
		imgData.data[0+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = ((191/(iterationMidpoint-1))*(((escapeCount3[i]+mode4ModuloOffset)%maxIterations)))+13;
		imgData.data[1+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = ((63/(iterationMidpoint-1))*(((escapeCount3[i]+mode4ModuloOffset)%maxIterations)))+8;
		imgData.data[2+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = ((-15/(iterationMidpoint-1))*(((escapeCount3[i]+mode4ModuloOffset)%maxIterations)))+135;
		imgData.data[3+((glowXArray3[i]*4)+((glowYArray3[i])*8*outputBoxSize))] = 255;
}

	if (((escapeCount4[i]+mode4ModuloOffset)%maxIterations)<iterationMidpoint){
		imgData.data[0+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = ((191/(iterationMidpoint-1))*(((escapeCount4[i]+mode4ModuloOffset)%maxIterations)))+13;
		imgData.data[1+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = ((63/(iterationMidpoint-1))*(((escapeCount4[i]+mode4ModuloOffset)%maxIterations)))+8;
		imgData.data[2+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = ((-15/(iterationMidpoint-1))*(((escapeCount4[i]+mode4ModuloOffset)%maxIterations)))+135;
		imgData.data[3+((glowXArray4[i]*4)+((glowYArray4[i])*8*outputBoxSize))] = 255;

}

}
}



/*
//  const imgData = ctx.getImageData(0, 0, 2*outputBoxSize, 2*outputBoxSize);

//	const imgData = [];
  // invert colors
  for (let i = 0; i < escapeCount.length; i += 4) {
    imgData.data[i] = 255 - escapeCount[i];
    imgData.data[i+1] = 255 - escapeCount[i];
    imgData.data[i+2] = 255 - escapeCount[i];
    imgData.data[i+3] = 255;
  }

*/

if (fourQuadrantBypass==0){ctx.putImageData(imgData, -1, -1);}






}


function oneOrthantRender(){
console.log("1 oh render called");



const canvasz = document.getElementById("zoomCanvas");
const ctxz = canvasz.getContext("2d");
ctxz.imageSmoothingEnabled = true;
ctxz.imageSmoothingQuality = "high";
canvasz.height = canvasz.width;
ctxz.transform(1, 0, 0, -1, 0, canvasz.height);




download_img = function(ell) {
  // get image URI from canvas object
  var imageURI = canvasz.toDataURL("image/realOrthantSign imOrthantSign");
  ell.href = imageURI;
};

const imgDataz = ctxz.createImageData(outputBoxSize, outputBoxSize);



/////COLORMODES


	if (colorMode==1){

	const glowXArray=[];
	const glowYArray=[];
		const glowXArray2=[];
	const glowYArray2=[];
		const glowXArray3=[];
	const glowYArray3=[];
		const glowXArray4=[];
	const glowYArray4=[];
	for (let i = 0; i < escapeCount.length-1; i++){
		let escapeIncrement=255/maxIterations;

		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize-((i%outputBoxSize));
		glowXArray.push(x);
		glowYArray.push(y);


		imgDataz.data[0+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = escapeCount[i]*escapeIncrement;
		imgDataz.data[1+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = escapeCount[i]*escapeIncrement;
		imgDataz.data[2+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = escapeCount[i]*escapeIncrement;
		imgDataz.data[3+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = escapeCount[i]*escapeIncrement;
}}

	if (colorMode==2){

	const glowXArray=[];
	const glowYArray=[];
		const glowXArray2=[];
	const glowYArray2=[];
		const glowXArray3=[];
	const glowYArray3=[];
		const glowXArray4=[];
	const glowYArray4=[];
	for (let i = 0; i < escapeCount.length-1; i++){
		let escapeIncrement=255/maxIterations;

		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize-((i%outputBoxSize));
		glowXArray.push(x);
		glowYArray.push(y);
		let x2=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y2=outputBoxSize-((i%outputBoxSize));
		glowXArray2.push(x2);
		glowYArray2.push(y2-1);
				let x3=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y3=outputBoxSize+((i%outputBoxSize));
		glowXArray3.push(x3);
		glowYArray3.push(y3-1);
		let x4=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y4=outputBoxSize+((i%outputBoxSize));
		glowXArray4.push(x4);
		glowYArray4.push(y4);
		
		imgDataz.data[0+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = (((escapeCount[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgDataz.data[1+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = (((escapeCount[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgDataz.data[2+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = (((escapeCount[i]+mode2ModuloOffset)%maxIterations)*escapeIncrement);
		imgDataz.data[3+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 255;



}
}



	if (colorMode==3){

	let iterationMidpoint=Math.round(maxIterations/2);

//highest escapeCount -> 253,231,37
//midpoint escapeCount -> 31, 145, 140
//lowest escapeCount -> 68,1,84
	const glowXArray=[];
	const glowYArray=[];
		const glowXArray2=[];
	const glowYArray2=[];
		const glowXArray3=[];
	const glowYArray3=[];
		const glowXArray4=[];
	const glowYArray4=[];
	for (let i = 0; i < escapeCount.length-1; i++){
		let escapeIncrement=255/maxIterations;

		let x=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize-((i%outputBoxSize));
		glowXArray.push(x);
		glowYArray.push(y);
		let x2=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y2=outputBoxSize-((i%outputBoxSize));
		glowXArray2.push(x2);
		glowYArray2.push(y2-1);
				let x3=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y3=outputBoxSize+((i%outputBoxSize));
		glowXArray3.push(x3);
		glowYArray3.push(y3-1);
		let x4=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y4=outputBoxSize+((i%outputBoxSize));
		glowXArray4.push(x4);
		glowYArray4.push(y4);
		
if (((escapeCount[i]+mode3ModuloOffset)%maxIterations)==iterationMidpoint){ 31, 145, 140
		imgDataz.data[0+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 31;
		imgDataz.data[1+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 145;
		imgDataz.data[2+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 140;
		imgDataz.data[3+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 255;


} else if (((escapeCount[i]+mode3ModuloOffset)%maxIterations)>iterationMidpoint){ 

//highest escapeCount -> 253,231,37
//midpoint escapeCount -> 31, 145, 140
//lowest escapeCount -> 68,1,84

	
		imgDataz.data[0+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = ((222/(iterationMidpoint-1))*(((escapeCount[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+31;
		imgDataz.data[1+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = ((86/(iterationMidpoint-1))*(((escapeCount[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+145;
		imgDataz.data[2+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = ((-103/(iterationMidpoint-1))*(((escapeCount[i]+mode3ModuloOffset)%maxIterations)-iterationMidpoint))+140;
		imgDataz.data[3+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 255;

} 


	if (((escapeCount[i]+mode3ModuloOffset)%maxIterations)<iterationMidpoint){

//highest escapeCount -> 253,231,37
//midpoint escapeCount -> 31, 145, 140
//lowest escapeCount -> 68,1,84

		imgDataz.data[0+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = ((37/(iterationMidpoint-1))*(((escapeCount[i]+mode3ModuloOffset)%maxIterations)))+31;
		imgDataz.data[1+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = ((143/(iterationMidpoint-1))*(((escapeCount[i]+mode3ModuloOffset)%maxIterations)))+1;
		imgDataz.data[2+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = ((56/(iterationMidpoint-1))*(((escapeCount[i]+mode3ModuloOffset)%maxIterations)))+84;
		imgDataz.data[3+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 255;


}

}
}


/////COLORMODE4

	if (colorMode==4){

	let iterationMidpoint=Math.round(maxIterations/2);

//mode 4 emulates plasma from matplotlib with RGB ranges 240-13 (midpoint ~204); 249, 8 (midpoint ~71); 33-135 (midpoint ~120); mode 3 also has a mode4ModuloOffset parameter.

//high 240,249,33
//midpoint - 204,71,120
//low - 13,8,135

	const glowXArray=[];
	const glowYArray=[];
		const glowXArray2=[];
	const glowYArray2=[];
		const glowXArray3=[];
	const glowYArray3=[];
		const glowXArray4=[];
	const glowYArray4=[];
	for (let i = 0; i < escapeCount.length-1; i++){
		let escapeIncrement=255/maxIterations;

		let x=(outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y=outputBoxSize-((i%outputBoxSize));
		glowXArray.push(x);
		glowYArray.push(y);
		let x2=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y2=outputBoxSize-((i%outputBoxSize));
		glowXArray2.push(x2);
		glowYArray2.push(y2-1);
				let x3=(2*outputBoxSize)+(((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y3=outputBoxSize+((i%outputBoxSize));
		glowXArray3.push(x3);
		glowYArray3.push(y3-1);
		let x4=(2*outputBoxSize)+(-1*((Math.floor(i/outputBoxSize+1))%(outputBoxSize+1)));
		let y4=outputBoxSize+((i%outputBoxSize));
		glowXArray4.push(x4);
		glowYArray4.push(y4);
		
if (((escapeCount[i]+mode4ModuloOffset)%maxIterations)==iterationMidpoint){ 
		imgDataz.data[0+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 204;
		imgDataz.data[1+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 71;
		imgDataz.data[2+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 120;
		imgDataz.data[3+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 255;

} else if (((escapeCount[i]+mode4ModuloOffset)%maxIterations)>iterationMidpoint){ 

//high 240,249,33
//midpoint - 204,71,120
//low - 13,8,135

	
		imgDataz.data[0+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = ((36/(iterationMidpoint-1))*(((escapeCount[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+204;
		imgDataz.data[1+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = ((178/(iterationMidpoint-1))*(((escapeCount[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+71;
		imgDataz.data[2+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = ((-87/(iterationMidpoint-1))*(((escapeCount[i]+mode4ModuloOffset)%maxIterations)-iterationMidpoint))+120;
		imgDataz.data[3+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 255;

}

	if (((escapeCount[i]+mode4ModuloOffset)%maxIterations)<iterationMidpoint){

//high 240,249,33
//midpoint - 204,71,120
//low - 13,8,135

		imgDataz.data[0+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = ((191/(iterationMidpoint-1))*(((escapeCount[i]+mode4ModuloOffset)%maxIterations)))+13;
		imgDataz.data[1+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = ((63/(iterationMidpoint-1))*(((escapeCount[i]+mode4ModuloOffset)%maxIterations)))+8;
		imgDataz.data[2+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = ((-15/(iterationMidpoint-1))*(((escapeCount[i]+mode4ModuloOffset)%maxIterations)))+135;
		imgDataz.data[3+((glowXArray[i]*4)+((glowYArray[i])*4*outputBoxSize))] = 255;


}

}
}

ctxz.putImageData(imgDataz, 0, -2);



}

function renderCompleteMessage(){

		let renderProgressComplete="render complete";
		document.getElementById("renderprogress").innerHTML = renderProgressComplete;

}

function renderingMessage(){

		renderProgress="rendering...";
		document.getElementById("renderprogress").innerHTML = renderProgress;

}

///END OF FUNCTION DECLARATIONS



      
        //you don't have to have contingent relationships if you are manipulating the quadrants manually.
        
        
        
    </script>
      <br><br><br>
        
    <br><br><br>
&copy; 2024-Present, Ben Blohowiak<br><br>

Questions? Feedback? <br><em>ben</em> at <em>benblohowiak dot com</em>
</body>
